<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GRPC: A powerful way to improve your Golang APIs | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/><link crossorigin=anonymous href=/assets/css/stylesheet.1d044a8ae143a71443a33febc372f95f5ce9087d07078feec050ae02388800f5.css integrity="sha256-HQRKiuFDpxRDoz/rw3L5X1zpCH0HB4/uwFCuAjiIAPU=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="GRPC: A powerful way to improve your Golang APIs"><meta property="og:description" content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-12-05T17:00:00+00:00"><meta property="article:modified_time" content="2019-12-05T17:00:00+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="GRPC: A powerful way to improve your Golang APIs"><meta name=twitter:description content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"GRPC: A powerful way to improve your Golang APIs","item":"https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GRPC: A powerful way to improve your Golang APIs","name":"GRPC: A powerful way to improve your Golang APIs","description":"Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them.","keywords":[],"articleBody":"Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them.\nWhy REST is popular and what are its pitfalls? Companies used to write web-services in SOAP until REST got enough hype to be the next big thing, although the concept has been around since 2000. It was like a fresh breeze for developers. It had a low learning curve, simplified payload (usually JSON instead of XML), schema-less approach and no need for specific clients/server generators.\nAt a certain point, some of its strengths shown to be some of its weaknesses. Not having a schema initially seemed a good idea, but developers eventually realised it is required. It can be useful for validation, documentation, contract agreement between teams and code-generation, to mention a few. Initiatives such as Swagger, RAML and most recently OpenAPI popped up trying to fill these gaps.\nEven though, a lack of an official standard to guide through decision processes usually ended up in analysis paralysis in big projects. Besides, code generation in most of these tools was not as good and ready to use (example: swagger-tools).\nJSON is the preferred way to return data from REST APIs. It is an excellent choice for public services used by front-end applications and third-parties. Due to its overhead on transporting and decoding, it is not well optimised for communication between internal services.\nEven with these issues, it doesn’t mean REST is a bad choice. It is by far the simplest way to implement an API, but there are known pitfalls due to its simplicity. Technologies such as GraphQL, Thrift and GRPC come to fill these gaps.\nEnters GRPC and Protocol Buffers GRPC is a modern Remote Procedure Call (RPC) framework built on top-off HTTP 2.0, using Protocol Buffers as its interface definition language (IDL). These help it to be a low latency, high performance and scalable option to REST.\nThe strict use of HTTP 2.0 enables developers to embrace some of its features, mainly streaming (client-side and server-side). For example:\nA client can send a bulk of messages through a stream, instead of sending one request each or one with all of them A client can send a request and receive a stream of responses, instead of waiting for the server to finish the processing and send a huge payload Protocol Buffers are a simpler and optimised way to define and serialise structured data. It can be used not only with GRPC but for other use cases, such as event modelling and data storage.\nThink Swagger (REST) or WSDL (SOAP), but lightweight due to the fact the payloads are binary, allowing faster serialisation and smaller footprint. Being generated by tools such as protoc, it brings some benefits such as type checking in compile-time and auto-completion in IDEs.\nIn the snippet below, a GRPC service is defined using Protobuf. Generating a client and server requires a simple protoc call. Easy right?\nsyntax = \"proto3\"; package api; // Defines where your go package will be placed after compilation option go_package = \"api\"; service Identity { rpc GetUser (GetUserRequest) returns (GetUserResponse) {} rpc GetUsers (GetUsersRequest) returns (GetUsersResponse) {} } message User { string user_id = 1; string name = 2; bool active = 3; } message GetUserRequest { string user_id = 1; } message GetUserResponse { User user = 1; } message GetUsersRequest {} message GetUsersResponse { // Defines an array of users repeated User users = 1; } In any protobuf file, each field has a number associated with it. These uniquely identify a position of a field in the binary message, so they shouldn’t be changed. If one of these gets deprecated, they can’t be re-used. It helps on avoiding breaking changes, allowing a progressive model evolution. Developers don’t need to worry about fields being re-used and clashing with previous payloads of the message.\nCreating a simple GRPC server and client in Golang Code of this part available at Github brunoluiz/grpc-example@master\nIt is possible to create a simple GRPC server and client based on the previous protobuf definition. The following tools need to be installed:\nProtocol buffers compiler Golang protoc plugin In a Golang project, running protoc -I. --go_out=plugins=grpc:./generated api/api.proto will generate both server and client. The go_package option in the protobuf specifies the generated code output path. In this case it will be ./generated/api.\nTo create a server, all methods defined by the proto need to be implemented by a Golang type. Peaking into the generated files, this is the interface generated from service Identity. A type which implements this interface should be enough to implement the server.\n// File: api/generated/api.pb.go type IdentityServer interface { GetUser(context.Context, *GetUserRequest) (*GetUserResponse, error) GetUsers(context.Context, *GetUsersRequest) (*GetUsersResponse, error) } // File: service/service.go type GRPCServer struct {} func (g *GRPCServer) GetUser(_ context.Context, _ *api.GetUserRequest) (*api.GetUserResponse, error) { ... } func (g *GRPCServer) GetUsers(_ context.Context, _ *api.GetUsersRequest) (*api.GetUsersResponse, error) { ... } With its implementation, the following code will be enough to run it as a server.\n// File: cmd/server/main.go // Create a new GRPC Server s := grpc.NewServer() // Register our service implementation against the GRPC service api.RegisterIdentityServer(s, service.NewServer()) // Listen to a specific port lis, err := net.Listen(\"tcp\", os.Getenv(\"GRPC_ADDRESS\")) if err != nil { return err } // Start serving return s.Serve(lis) A client will be generated by protoc as well. It can be created through NewIdentityClient, returning an IdentityClient implementation.\n// File: api/generated/api.pb.go type IdentityClient interface { GetUser(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*GetUserResponse, error) GetUsers(ctx context.Context, in *GetUsersRequest, opts ...grpc.CallOption) (*GetUsersResponse, error) } // File: cmd/client/main.go // Set up a connection to the server. conn, err := grpc.Dial(c.String(\"grpc-address\"), grpc.WithInsecure(), grpc.WithBlock()) if err != nil { return err } defer conn.Close() // Create GRPC Client client := api.NewIdentityClient(conn) // Call GRPC Service and Get User u, err := client.GetUser(context.Background(), \u0026api.GetUserRequest{ UserId: c.Args().Get(0), }) if err != nil { return errors.Wrap(err, \"issue on retrieving users\") } Of course, this is the bare minimum set-up for a client and server. Interceptors can be added on both client and server, adding custom hooks to any method call and applying some transformations.\nUnaryInterceptors deal with requests which expect a single response back. StreamInterceptors applies to any streamed response or request. In this article by David Bond, there is more information about interceptors and how to implement custom ones.\nMost common interceptors, such as authorisation, validation, monitoring can be found at go-grpc-middleware. Remember, don’t repeat yourself 😉\nCode of this part available at Github brunoluiz/grpc-example@master\nGRPC and REST together: What is this, a crossover episode? Code of this part available at Github brunoluiz/grpc-example@with-gateway\nAs previously mentioned, REST simplicity and low learning curve are some of its selling points. It allows quick testing, without the need to set-up a client binary – who never did a quick curl to check some API? Besides, it is easier for non-developers to play with it. As it is web services lingua franca, it might be required for third-party or front-end integrations as well.\nGRPC might be more efficient and better in some cases, but it is not as straightforward to use as REST. What if both could be used together, within the same service? That is where GRPC Gateway shines, integrating both worlds in one.\nThrough annotations, a service can define which methods will be exposed as REST. Using the previous GRPC protobuf, here is an example – note the google.api.http options:\nimport \"google/api/annotations.proto\"; service Identity { rpc GetUser (GetUserRequest) returns (GetUserResponse) { // Maps GetUser to an HTTP GET request, with the param `user_id` // been mapped to GetUserRequest.user_id option (google.api.http) = { get: \"/v1/users/{user_id}\" }; } rpc GetUsers (GetUsersRequest) returns (GetUsersResponse) { // Maps GetUsers to an HTTP GET request option (google.api.http) = { get: \"/v1/users\" }; } } With annotations in place, protoc needs to be changed to use the grpc-gateway plugin.\nInstall grpc-gateway locally Add GRPC Gateway paths to import paths (-I$(GOPATH)/src/github.com/grpc-ecosystem/grpc-gateway/third\\_party/googleapis) Add --grpc-gateway_out=logtostderr=true:./generated to generate gateway code. It will place at go_package path Add --grpc-swagger_out=logtostderr=true:. to generate Swagger definitions. It will place it in the same folder as the proto file. protoc -I. \\ -I$(GOPATH)/src \\ -I$(GOPATH)/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \\ --grpc-gateway_out=logtostderr=true:./generated \\ --swagger_out=logtostderr=true:. \\ --go_out=plugins=grpc:./generated \\ api/api.proto After running protoc, the reverse-proxy code will be available for use. It is just a matter of creating an HTTP server for it. The following implementation is running it in a separate server.\n// File: cmd/gateway/main.go // Note: Make sure the gRPC server is running properly and accessible mux := runtime.NewServeMux() opts := []grpc.DialOption{grpc.WithInsecure()} // Register gRPC server endpoint if err := api.RegisterIdentityHandlerFromEndpoint( context.Background(), mux, c.String(\"grpc-address\"), opts) ); err != nil { return err } // Start HTTP reverse proxy: sends calls to GRPC server return http.ListenAndServe(c.String(\"gateway-address\"), mux) Any REST client should be able to request data from the Gateway. Server up, this is curl’s output:\n➜ ~ curl localhost:8080/v1/users {\"users\":[{\"user_id\":\"xyz\",\"name\":\"Pelican Steve\",\"active\":true},{\"user_id\":\"foo\",\"name\":\"John Doe\",\"active\":true},{\"user_id\":\"bar\",\"name\":\"Chauffina Carr\",\"active\":true}]} ➜ ~ curl localhost:8080/v1/users/xyz {\"user\":{\"user_id\":\"xyz\",\"name\":\"Pelican Steve\",\"active\":true}} ➜ ~ curl localhost:8080/v1/users/aaa {\"error\":\"resource was not found\",\"code\":5,\"message\":\"resource was not found\"}% Magic, isn’t it? Having this REST set-up might put a smile on some faces. The service can be migrated to GRPC for internal usage, keeping compatibility with REST clients – third-parties, non-techies and front-end applications.\nThere is an excellent talk by Johan Brandhorst giving more details on GRPC Gateway.\nCode of this part available at Github brunoluiz/grpc-example@with-gateway\nFantastic debugging tools and where to find them Sooner or later, a quick peek into the service will be required, for debugging or scriptting purposes. In REST this can be done through tools such as curl, Insomnia or Postman. In GRPC, a different set of tools is required.\nFor the Graphical Interface lovers, the most popular one is BloomRPC. It only requires the proto files to be loaded and then it works similarly to any other REST client.\nFor mouse avoiders – or terminal lovers 😅 – there are two quite useful tools. GRPCurl is an awesome CLI tool, resembling curl and allow easy GRPC automation and scripting. A simple example of its usage follows:\ngrpcurl --plaintext --proto api/api.proto localhost:5000 api.Identity/GetUsers\nEvans goes a little bit further, as it has a REPL mode as well, allowing easier resource inspections (my favourite).\nThese tools, GUI or not, are quite useful while testing and inspecting GRPC services. Try them and find the one which fits your needs better 😉\nMy experience using it In my workplace GRPC has proved quite useful for connecting services, especially internal ones. Protocol Buffers came to be our main IDL when defining contracts for APIs and Stream Events. Due to these contracts, communicating implementations and changes are easier.\nImplementing service clients and servers had been easier and faster. The most common issue is due to include paths errors, which sometimes get messy. But this is more due to our learnings around it than the technology itself. Some of the boilerplate, such as registering the server or dialing the client, can be tackled by creating custom protoc plugins. This proved quite useful, specially when the team is more product-oriented.\nFor Golang, it proved to work quite well in most cases, with good community support. But, protoc can generate code to other languages as well, such as NodeJS and Java. Although, in our NodeJS services, we felt GRPC support is still lacking behind Golang.\nIn general, GRPC has been a good choice for our services. Hopefully, it will be good for your team as well.\n","wordCount":"1902","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2019-12-05T17:00:00Z","dateModified":"2019-12-05T17:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GRPC: A powerful way to improve your Golang APIs</h1><div class=post-meta><span title='2019-12-05 17:00:00 +0000 UTC'>December 5, 2019</span>&nbsp;·&nbsp;9 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover_hu_6aeea8d625b8688.jpg 360w,https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover_hu_20909a40de9f8c27.jpg 480w,https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover_hu_fef6ade9771c845f.jpg 720w,https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover_hu_d81abbfd268d893c.jpg 1080w,https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover_hu_af40ebb1ba3ec64d.jpg 1500w,https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover.jpg 5311w' src=https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=5311 height=3541 alt="Photo by Israel Palacio on Unsplash"><figcaption>Photo by Israel Palacio on Unsplash</figcaption></figure><div class=post-content><p>Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them.</p><h1 id=why-rest-is-popular-and-what-are-its-pitfalls>Why REST is popular and what are its pitfalls?<a hidden class=anchor aria-hidden=true href=#why-rest-is-popular-and-what-are-its-pitfalls>#</a></h1><p>Companies used to write web-services in SOAP until REST got enough hype to be the next big thing, although the concept has been around since 2000. It was like a fresh breeze for developers. It had a low learning curve, simplified payload (usually JSON instead of XML), schema-less approach and no need for specific clients/server generators.</p><p>At a certain point, some of its strengths shown to be some of its weaknesses. Not having a schema initially seemed a good idea, but developers eventually realised it is required. It can be useful for validation, documentation, contract agreement between teams and code-generation, to mention a few. Initiatives such as Swagger, RAML and most recently OpenAPI popped up trying to fill these gaps.</p><p>Even though, a lack of an official standard to guide through decision processes usually ended up in analysis paralysis in big projects. Besides, code generation in most of these tools was not as good and ready to use (example: swagger-tools).</p><p>JSON is the preferred way to return data from REST APIs. It is an excellent choice for public services used by front-end applications and third-parties. Due to its overhead on transporting and decoding, it is not well optimised for communication between internal services.</p><p>Even with these issues, it doesn&rsquo;t mean REST is a bad choice. It is by far the simplest way to implement an API, but there are known pitfalls due to its simplicity. Technologies such as GraphQL, Thrift and GRPC come to fill these gaps.</p><h1 id=enters-grpc-and-protocol-buffers>Enters GRPC and Protocol Buffers<a hidden class=anchor aria-hidden=true href=#enters-grpc-and-protocol-buffers>#</a></h1><p>GRPC is a modern Remote Procedure Call (RPC) framework built on top-off HTTP 2.0, using Protocol Buffers as its interface definition language (IDL). These help it to be a low latency, high performance and scalable option to REST.</p><p>The strict use of HTTP 2.0 enables developers to embrace some of its features, mainly streaming (client-side and server-side). For example:</p><ul><li>A client can send a bulk of messages through a stream, instead of sending one request each or one with all of them</li><li>A client can send a request and receive a stream of responses, instead of waiting for the server to finish the processing and send a huge payload</li></ul><p>Protocol Buffers are a simpler and optimised way to define and serialise structured data. It can be used not only with GRPC but for other use cases, such as event modelling and data storage.</p><p>Think Swagger (REST) or WSDL (SOAP), but lightweight due to the fact the payloads are binary, allowing faster serialisation and smaller footprint. Being generated by tools such as <code>protoc</code>, it brings some benefits such as type checking in compile-time and auto-completion in IDEs.</p><p>In the snippet below, a GRPC service is defined using Protobuf. Generating a client and server requires a simple <code>protoc</code> call. Easy right?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> api;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// Defines where your go package will be placed after compilation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;api&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> Identity {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUser (GetUserRequest) <span style=color:#66d9ef>returns</span> (GetUserResponse) {}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUsers (GetUsersRequest) <span style=color:#66d9ef>returns</span> (GetUsersResponse) {}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>User</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> user_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>bool</span> active <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUserRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> user_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUserResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  User user <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUsersRequest</span> {}<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUsersResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#75715e>// Defines an array of users
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>repeated</span> User users <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>In any protobuf file, each field has a number associated with it. These uniquely identify a position of a field in the binary message, so they shouldn’t be changed. If one of these gets deprecated, they can&rsquo;t be re-used. It helps on avoiding breaking changes, allowing a progressive model evolution. Developers don&rsquo;t need to worry about fields being re-used and clashing with previous payloads of the message.</p><h1 id=creating-a-simple-grpc-server-and-client-in-golang>Creating a simple GRPC server and client in Golang<a hidden class=anchor aria-hidden=true href=#creating-a-simple-grpc-server-and-client-in-golang>#</a></h1><p><em><a href=https://github.com/brunoluiz/grpc-example>Code of this part available at Github brunoluiz/grpc-example@master</a></em></p><p>It is possible to create a simple GRPC server and client based on the previous protobuf definition. The following tools need to be installed:</p><ul><li><a href=https://github.com/protocolbuffers/protobuf>Protocol buffers compiler</a></li><li><a href=https://github.com/golang/protobuf>Golang protoc plugin</a></li></ul><p>In a Golang project, running <code>protoc -I. --go_out=plugins=grpc:./generated api/api.proto</code> will generate both server and client. The <code>go_package</code> option in the protobuf specifies the generated code output path. In this case it will be <code>./generated/api</code>.</p><p>To create a server, all methods defined by the proto need to be implemented by a Golang type. Peaking into the generated files, this is the interface generated from <code>service Identity</code>. A type which implements this interface should be enough to implement the server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: api/generated/api.pb.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IdentityServer</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: service/service.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GRPCServer</span> <span style=color:#66d9ef>struct</span> {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GRPCServer</span>) <span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GRPCServer</span>) <span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUsersRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
</span></span></code></pre></div><p>With its implementation, the following code will be enough to run it as a server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: cmd/server/main.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create a new GRPC Server</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>NewServer</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Register our service implementation against the GRPC service</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>RegisterIdentityServer</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>service</span>.<span style=color:#a6e22e>NewServer</span>())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Listen to a specific port</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>lis</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#e6db74>&#34;GRPC_ADDRESS&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Start serving</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>lis</span>)
</span></span></code></pre></div><p>A client will be generated by <code>protoc</code> as well. It can be created through <code>NewIdentityClient</code>, returning an <code>IdentityClient</code> implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: api/generated/api.pb.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IdentityClient</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserRequest</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersRequest</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: cmd/client/main.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Set up a connection to the server.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;grpc-address&#34;</span>), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>(), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithBlock</span>())
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Create GRPC Client</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>NewIdentityClient</span>(<span style=color:#a6e22e>conn</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Call GRPC Service and Get User</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserRequest</span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>UserId</span>: <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Args</span>().<span style=color:#a6e22e>Get</span>(<span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;issue on retrieving users&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Of course, this is the bare minimum set-up for a client and server. Interceptors can be added on both client and server, adding custom hooks to any method call and applying some transformations.</p><p>UnaryInterceptors deal with requests which expect a single response back. StreamInterceptors applies to any streamed response or request. <a href=https://davidsbond.github.io/2019/06/14/creating-grpc-interceptors-in-go.html>In this article</a> by David Bond, there is more information about interceptors and how to implement custom ones.</p><p>Most common interceptors, such as authorisation, validation, monitoring can be found at <a href=https://github.com/grpc-ecosystem/go-grpc-middleware>go-grpc-middleware</a>. Remember, don&rsquo;t repeat yourself 😉</p><p><em><a href=https://github.com/brunoluiz/grpc-example>Code of this part available at Github brunoluiz/grpc-example@master</a></em></p><h1 id=grpc-and-rest-together-what-is-this-a-crossover-episode>GRPC and REST together: What is this, a crossover episode?<a hidden class=anchor aria-hidden=true href=#grpc-and-rest-together-what-is-this-a-crossover-episode>#</a></h1><p><em><a href=https://github.com/brunoluiz/grpc-example/pull/1>Code of this part available at Github brunoluiz/grpc-example@with-gateway</a></em></p><p>As previously mentioned, REST simplicity and low learning curve are some of its selling points. It allows quick testing, without the need to set-up a client binary &ndash; who never did a quick <code>curl</code> to check some API? Besides, it is easier for non-developers to play with it. As it is web services <em>lingua franca,</em> it might be required for third-party or front-end integrations as well.</p><p>GRPC might be more efficient and better in some cases, but it is not as straightforward to use as REST. What if both could be used together, within the same service? That is where <a href=https://github.com/grpc-ecosystem/grpc-gateway>GRPC Gateway</a> shines, integrating both worlds in one.</p><p>Through annotations, a service can define which methods will be exposed as REST. Using the previous GRPC protobuf, here is an example &ndash; note the <code>google.api.http</code> options:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=display:flex><span><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;google/api/annotations.proto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> Identity {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUser (GetUserRequest) <span style=color:#66d9ef>returns</span> (GetUserResponse) {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#75715e>// Maps GetUser to an HTTP GET request, with the param `user_id`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// been mapped to GetUserRequest.user_id
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>option</span> (google.api.http) <span style=color:#f92672>=</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>      get<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/v1/users/{user_id}&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUsers (GetUsersRequest) <span style=color:#66d9ef>returns</span> (GetUsersResponse) {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#75715e>// Maps GetUsers to an HTTP GET request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>option</span> (google.api.http) <span style=color:#f92672>=</span> {<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>      get<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/v1/users&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><p>With annotations in place, <code>protoc</code> needs to be changed to use the <code>grpc-gateway</code> plugin.</p><ul><li><a href=https://github.com/grpc-ecosystem/grpc-gateway#installation>Install grpc-gateway locally</a></li><li>Add GRPC Gateway paths to import paths (<code>-I$(GOPATH)/src/github.com/grpc-ecosystem/grpc-gateway/third\_party/googleapis</code>)</li><li>Add <code>--grpc-gateway_out=logtostderr=true:./generated</code> to generate gateway code. It will place at <code>go_package</code> path</li><li>Add <code>--grpc-swagger_out=logtostderr=true:.</code> to generate Swagger definitions. It will place it in the same folder as the proto file.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>protoc</span> <span style=color:#960050;background-color:#1e0010>-I.</span> <span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>-I</span><span style=color:#66d9ef>$(</span>GOPATH<span style=color:#66d9ef>)</span><span style=color:#960050;background-color:#1e0010>/src</span> <span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>-I</span><span style=color:#66d9ef>$(</span>GOPATH<span style=color:#66d9ef>)</span><span style=color:#960050;background-color:#1e0010>/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis</span> <span style=color:#960050;background-color:#1e0010>\</span>
</span></span><span style=display:flex><span>  --grpc-gateway_out<span style=color:#f92672>=</span>logtostderr<span style=color:#f92672>=</span>true:./generated <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --swagger_out<span style=color:#f92672>=</span>logtostderr<span style=color:#f92672>=</span>true:. <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --go_out<span style=color:#f92672>=</span>plugins<span style=color:#f92672>=</span>grpc:./generated <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  api/api.proto
</span></span></code></pre></div><p>After running <code>protoc</code>, the reverse-proxy code will be available for use. It is just a matter of creating an HTTP server for it. The following implementation is running it in a separate server.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// File: cmd/gateway/main.go</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Note: Make sure the gRPC server is running properly and accessible</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NewServeMux</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>opts</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>DialOption</span>{<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>()}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Register gRPC server endpoint</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>RegisterIdentityHandlerFromEndpoint</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#a6e22e>mux</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;grpc-address&#34;</span>), <span style=color:#a6e22e>opts</span>)
</span></span><span style=display:flex><span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Start HTTP reverse proxy: sends calls to GRPC server</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;gateway-address&#34;</span>), <span style=color:#a6e22e>mux</span>)
</span></span></code></pre></div><p>Any REST client should be able to request data from the Gateway. Server up, this is curl&rsquo;s output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>➜  ~ curl localhost:8080/v1/users
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;users&#34;</span>:<span style=color:#f92672>[{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;xyz&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Pelican Steve&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}</span>,<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;foo&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;John Doe&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}</span>,<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;bar&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Chauffina Carr&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}]}</span>
</span></span><span style=display:flex><span>➜  ~ curl localhost:8080/v1/users/xyz
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user&#34;</span>:<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;xyz&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Pelican Steve&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}}</span>
</span></span><span style=display:flex><span>➜  ~ curl localhost:8080/v1/users/aaa
</span></span><span style=display:flex><span><span style=color:#f92672>{</span><span style=color:#e6db74>&#34;error&#34;</span>:<span style=color:#e6db74>&#34;resource was not found&#34;</span>,<span style=color:#e6db74>&#34;code&#34;</span>:5,<span style=color:#e6db74>&#34;message&#34;</span>:<span style=color:#e6db74>&#34;resource was not found&#34;</span><span style=color:#f92672>}</span>%
</span></span></code></pre></div><p>Magic, isn&rsquo;t it? Having this REST set-up might put a smile on some faces. The service can be migrated to GRPC for internal usage, keeping compatibility with REST clients &ndash; third-parties, non-techies and front-end applications.</p><p><a href=https://www.gophercon.co.uk/videos/2019/writing-rest-services-for-the-grpc-curious/>There is an excellent talk</a> by Johan Brandhorst giving more details on GRPC Gateway.</p><p><em><a href=https://github.com/brunoluiz/grpc-example/pull/1>Code of this part available at Github brunoluiz/grpc-example@with-gateway</a></em></p><h1 id=fantastic-debugging-tools-and-where-to-find-them>Fantastic debugging tools and where to find them<a hidden class=anchor aria-hidden=true href=#fantastic-debugging-tools-and-where-to-find-them>#</a></h1><p>Sooner or later, a quick peek into the service will be required, for debugging or scriptting purposes. In REST this can be done through tools such as curl, Insomnia or Postman. In GRPC, a different set of tools is required.</p><p>For the Graphical Interface lovers, the most popular one is <a href=https://github.com/uw-labs/bloomrpc>BloomRPC</a>. It only requires the proto files to be loaded and then it works similarly to any other REST client.</p><p><img alt="BloomRPC demo" loading=lazy src=https://github.com/uw-labs/bloomrpc/raw/873953c6b00906a69f165c332634b946c7724fe9/resources/editor-preview.gif></p><p>For mouse avoiders &ndash; or terminal lovers 😅 &ndash; there are two quite useful tools. <a href=https://github.com/fullstorydev/grpcurl>GRPCurl</a> is an awesome CLI tool, resembling curl and allow easy GRPC automation and scripting. A simple example of its usage follows:</p><p><code>grpcurl --plaintext --proto api/api.proto localhost:5000 api.Identity/GetUsers</code></p><p><a href=https://github.com/ktr0731/evans>Evans</a> goes a little bit further, as it has a REPL mode as well, allowing easier resource inspections (my favourite).</p><p><img alt="Evan REPL Demo" loading=lazy src=https://github.com/ktr0731/evans/raw/97d1de81aa4ea471a14f4db56bf04830c6d79c39/evans1.gif></p><p>These tools, GUI or not, are quite useful while testing and inspecting GRPC services. Try them and find the one which fits your needs better 😉</p><h1 id=my-experience-using-it>My experience using it<a hidden class=anchor aria-hidden=true href=#my-experience-using-it>#</a></h1><p>In my workplace GRPC has proved quite useful for connecting services, especially internal ones. Protocol Buffers came to be our main IDL when defining contracts for APIs and Stream Events. Due to these contracts, communicating implementations and changes are easier.</p><p>Implementing service clients and servers had been easier and faster. The most common issue is due to include paths errors, which sometimes get messy. But this is more due to our learnings around it than the technology itself. Some of the boilerplate, such as registering the server or dialing the client, can be tackled by creating custom protoc plugins. This proved quite useful, specially when the team is more product-oriented.</p><p>For Golang, it proved to work quite well in most cases, with good community support. But, <code>protoc</code> can generate code to other languages as well, such as NodeJS and Java. Although, in our NodeJS services, we felt GRPC support is still lacking behind Golang.</p><p>In general, GRPC has been a good choice for our services. Hopefully, it will be good for your team as well.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/2020/sep/getting-good-code-reviews/><span class=title>« Prev</span><br><span>Getting good code reviews from peers</span>
</a><a class=next href=https://brunoluiz.net/blog/graphql-as-a-gateway/><span class=title>Next »</span><br><span>GraphQL feat API Gateway</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>