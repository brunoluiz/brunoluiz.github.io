<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>GRPC: A powerful way to improve your Golang APIs - Bruno Luiz Silva</title><meta name=description content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/><link href=https://brunoluiz.net/css/stylesheet.min.479df382e20c15ef754d9b2dbc0094ba0efd1852d5ae38da2dce805cd10a01bf.css integrity="sha256-R53zguIMFe91TZstvACUug79GFLVrjjaLc6AXNEKAb8=" rel="preload stylesheet" as=style><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=icon href=https://brunoluiz.net/favicon.ico><meta name=generator content="Hugo 0.75.1"><meta property="og:title" content="GRPC: A powerful way to improve your Golang APIs"><meta property="og:description" content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta property="og:type" content="article"><meta property="og:url" content="https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/"><meta property="og:image" content="https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover.jpg"><meta property="article:published_time" content="2019-12-05T17:00:00+00:00"><meta property="article:modified_time" content="2019-12-05T17:00:00+00:00"><meta property="og:site_name" content="Bruno Luiz Silva"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover.jpg"><meta name=twitter:title content="GRPC: A powerful way to improve your Golang APIs"><meta name=twitter:description content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta itemprop=name content="GRPC: A powerful way to improve your Golang APIs"><meta itemprop=description content="Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them."><meta itemprop=datePublished content="2019-12-05T17:00:00+00:00"><meta itemprop=dateModified content="2019-12-05T17:00:00+00:00"><meta itemprop=wordCount content="1885"><meta itemprop=image content="https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/cover.jpg"><meta itemprop=keywords content></head><body class=single id=top><script>if(window.matchMedia('(prefers-color-scheme: dark)').matches){document.body.classList.add('dark');}</script><header class=header><nav class=nav><p class=logo><a href=https://brunoluiz.net>Bruno Luiz Silva</a></p><ul class=menu id=menu onscroll=menu_on_scroll()></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>GRPC: A powerful way to improve your Golang APIs</h1><div class=post-meta><time>December 5, 2019</time>&nbsp;Â·&nbsp;9 min</div></header><div class=post-content><p><img loading=lazy src=cover.jpg alt="Photo by Israel Palacio on Unsplash"></p><p>Web APIs are everywhere, with REST being one of the most popular ways to distribute it. With recent technologies, there are better ways to implement them, GRPC been one of them.</p><h1 id=why-rest-is-popular-and-what-are-its-pitfalls>Why REST is popular and what are its pitfalls?</h1><p>Companies used to write web-services in SOAP until REST got enough hype to be the next big thing, although the concept has been around since 2000. It was like a fresh breeze for developers. It had a low learning curve, simplified payload (usually JSON instead of XML), schema-less approach and no need for specific clients/server generators.</p><p>At a certain point, some of its strengths shown to be some of its weaknesses. Not having a schema initially seemed a good idea, but developers eventually realised it is required. It can be useful for validation, documentation, contract agreement between teams and code-generation, to mention a few. Initiatives such as Swagger, RAML and most recently OpenAPI popped up trying to fill these gaps.</p><p>Even though, a lack of an official standard to guide through decision processes usually ended up in analysis paralysis in big projects. Besides, code generation in most of these tools was not as good and ready to use (example: swagger-tools).</p><p>JSON is the preferred way to return data from REST APIs. It is an excellent choice for public services used by front-end applications and third-parties. Due to its overhead on transporting and decoding, it is not well optimised for communication between internal services.</p><p>Even with these issues, it doesn&rsquo;t mean REST is a bad choice. It is by far the simplest way to implement an API, but there are known pitfalls due to its simplicity. Technologies such as GraphQL, Thrift and GRPC come to fill these gaps.</p><h1 id=enters-grpc-and-protocol-buffers>Enters GRPC and Protocol Buffers</h1><p>GRPC is a modern Remote Procedure Call (RPC) framework built on top-off HTTP 2.0, using Protocol Buffers as its interface definition language (IDL). These help it to be a low latency, high performance and scalable option to REST.</p><p>The strict use of HTTP 2.0 enables developers to embrace some of its features, mainly streaming (client-side and server-side). For example:</p><ul><li>A client can send a bulk of messages through a stream, instead of sending one request each or one with all of them</li><li>A client can send a request and receive a stream of responses, instead of waiting for the server to finish the processing and send a huge payload</li></ul><p>Protocol Buffers are a simpler and optimised way to define and serialise structured data. It can be used not only with GRPC but for other use cases, such as event modelling and data storage.</p><p>Think Swagger (REST) or WSDL (SOAP), but lightweight due to the fact the payloads are binary, allowing faster serialisation and smaller footprint. Being generated by tools such as <code>protoc</code>, it brings some benefits such as type checking in compile-time and auto-completion in IDEs.</p><p>In the snippet below, a GRPC service is defined using Protobuf. Generating a client and server requires a simple <code>protoc</code> call. Easy right?</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf>syntax <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;proto3&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#f92672>package</span> api;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#75715e>// Defines where your go package will be placed after compilation
</span><span style=color:#75715e></span><span style=color:#66d9ef>option</span> go_package <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;api&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> Identity {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUser (GetUserRequest) <span style=color:#66d9ef>returns</span> (GetUserResponse) {}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUsers (GetUsersRequest) <span style=color:#66d9ef>returns</span> (GetUsersResponse) {}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>User</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> user_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> name <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>bool</span> active <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUserRequest</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>string</span> user_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUserResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  User user <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUsersRequest</span> {}<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>message</span> <span style=color:#a6e22e>GetUsersResponse</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#75715e>// Defines an array of users
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>repeated</span> User users <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>In any protobuf file, each field has a number associated with it. These uniquely identify a position of a field in the binary message, so they shouldnât be changed. If one of these gets deprecated, they can&rsquo;t be re-used. It helps on avoiding breaking changes, allowing a progressive model evolution. Developers don&rsquo;t need to worry about fields being re-used and clashing with previous payloads of the message.</p><h1 id=creating-a-simple-grpc-server-and-client-in-golang>Creating a simple GRPC server and client in Golang</h1><p><em><a href=https://github.com/brunoluiz/grpc-example>Code of this part available at Github brunoluiz/grpc-example@master</a></em></p><p>It is possible to create a simple GRPC server and client based on the previous protobuf definition. The following tools need to be installed:</p><ul><li><a href=https://github.com/protocolbuffers/protobuf>Protocol buffers compiler</a></li><li><a href=https://github.com/golang/protobuf>Golang protoc plugin</a></li></ul><p>In a Golang project, running <code>protoc -I. --go_out=plugins=grpc:./generated api/api.proto</code> will generate both server and client. The <code>go_package</code> option in the protobuf specifies the generated code output path. In this case it will be <code>./generated/api</code>.</p><p>To create a server, all methods defined by the proto need to be implemented by a Golang type. Peaking into the generated files, this is the interface generated from <code>service Identity</code>. A type which implements this interface should be enough to implement the server.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: api/generated/api.pb.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IdentityServer</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: service/service.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>GRPCServer</span> <span style=color:#66d9ef>struct</span> {}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GRPCServer</span>) <span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>g</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GRPCServer</span>) <span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>_</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUsersRequest</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>) { <span style=color:#f92672>...</span> }
</code></pre></div><p>With its implementation, the following code will be enough to run it as a server.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: cmd/server/main.go
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Create a new GRPC Server
</span><span style=color:#75715e></span><span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>NewServer</span>()

<span style=color:#75715e>// Register our service implementation against the GRPC service
</span><span style=color:#75715e></span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>RegisterIdentityServer</span>(<span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>service</span>.<span style=color:#a6e22e>NewServer</span>())

<span style=color:#75715e>// Listen to a specific port
</span><span style=color:#75715e></span><span style=color:#a6e22e>lis</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>Listen</span>(<span style=color:#e6db74>&#34;tcp&#34;</span>, <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Getenv</span>(<span style=color:#e6db74>&#34;GRPC_ADDRESS&#34;</span>))
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}

<span style=color:#75715e>// Start serving
</span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Serve</span>(<span style=color:#a6e22e>lis</span>)
</code></pre></div><p>A client will be generated by <code>protoc</code> as well. It can be created through <code>NewIdentityClient</code>, returning an <code>IdentityClient</code> implementation.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: api/generated/api.pb.go
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IdentityClient</span> <span style=color:#66d9ef>interface</span> {
	<span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserRequest</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUserResponse</span>, <span style=color:#66d9ef>error</span>)
	<span style=color:#a6e22e>GetUsers</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>in</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersRequest</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>CallOption</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>GetUsersResponse</span>, <span style=color:#66d9ef>error</span>)
}
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: cmd/client/main.go
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Set up a connection to the server.
</span><span style=color:#75715e></span><span style=color:#a6e22e>conn</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>Dial</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;grpc-address&#34;</span>), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>(), <span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithBlock</span>())
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}
<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>Close</span>()

<span style=color:#75715e>// Create GRPC Client
</span><span style=color:#75715e></span><span style=color:#a6e22e>client</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>NewIdentityClient</span>(<span style=color:#a6e22e>conn</span>)

<span style=color:#75715e>// Call GRPC Service and Get User
</span><span style=color:#75715e></span><span style=color:#a6e22e>u</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>GetUser</span>(<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>GetUserRequest</span>{
  <span style=color:#a6e22e>UserId</span>: <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Args</span>().<span style=color:#a6e22e>Get</span>(<span style=color:#ae81ff>0</span>),
})
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>Wrap</span>(<span style=color:#a6e22e>err</span>, <span style=color:#e6db74>&#34;issue on retrieving users&#34;</span>)
}
</code></pre></div><p>Of course, this is the bare minimum set-up for a client and server. Interceptors can be added on both client and server, adding custom hooks to any method call and applying some transformations.</p><p>UnaryInterceptors deal with requests which expect a single response back. StreamInterceptors applies to any streamed response or request. <a href=https://davidsbond.github.io/2019/06/14/creating-grpc-interceptors-in-go.html>In this article</a> by David Bond, there is more information about interceptors and how to implement custom ones.</p><p>Most common interceptors, such as authorisation, validation, monitoring can be found at <a href=https://github.com/grpc-ecosystem/go-grpc-middleware>go-grpc-middleware</a>. Remember, don&rsquo;t repeat yourself ð</p><p><em><a href=https://github.com/brunoluiz/grpc-example>Code of this part available at Github brunoluiz/grpc-example@master</a></em></p><h1 id=grpc-and-rest-together-what-is-this-a-crossover-episode>GRPC and REST together: What is this, a crossover episode?</h1><p><em><a href=https://github.com/brunoluiz/grpc-example/pull/1>Code of this part available at Github brunoluiz/grpc-example@with-gateway</a></em></p><p>As previously mentioned, REST simplicity and low learning curve are some of its selling points. It allows quick testing, without the need to set-up a client binary &ndash; who never did a quick <code>curl</code> to check some API? Besides, it is easier for non-developers to play with it. As it is web services <em>lingua franca,</em> it might be required for third-party or front-end integrations as well.</p><p>GRPC might be more efficient and better in some cases, but it is not as straightforward to use as REST. What if both could be used together, within the same service? That is where <a href=https://github.com/grpc-ecosystem/grpc-gateway>GRPC Gateway</a> shines, integrating both worlds in one.</p><p>Through annotations, a service can define which methods will be exposed as REST. Using the previous GRPC protobuf, here is an example &ndash; note the <code>google.api.http</code> options:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-protobuf data-lang=protobuf><span style=color:#66d9ef>import</span> <span style=color:#e6db74>&#34;google/api/annotations.proto&#34;</span>;<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>service</span> Identity {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUser (GetUserRequest) <span style=color:#66d9ef>returns</span> (GetUserResponse) {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#75715e>// Maps GetUser to an HTTP GET request, with the param `user_id`
</span><span style=color:#75715e></span>    <span style=color:#75715e>// been mapped to GetUserRequest.user_id
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>option</span> (google.api.http) <span style=color:#f92672>=</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>      get<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/v1/users/{user_id}&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  <span style=color:#66d9ef>rpc</span> GetUsers (GetUsersRequest) <span style=color:#66d9ef>returns</span> (GetUsersResponse) {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    <span style=color:#75715e>// Maps GetUsers to an HTTP GET request
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>option</span> (google.api.http) <span style=color:#f92672>=</span> {<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>      get<span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;/v1/users&#34;</span><span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>    };<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>  }<span style=color:#960050;background-color:#1e0010>
</span><span style=color:#960050;background-color:#1e0010></span>}<span style=color:#960050;background-color:#1e0010>
</span></code></pre></div><p>With annotations in place, <code>protoc</code> needs to be changed to use the <code>grpc-gateway</code> plugin.</p><ul><li><a href=https://github.com/grpc-ecosystem/grpc-gateway#installation>Install grpc-gateway locally</a></li><li>Add GRPC Gateway paths to import paths (<code>-I$(GOPATH)/src/github.com/grpc-ecosystem/grpc-gateway/third\_party/googleapis</code>)</li><li>Add <code>--grpc-gateway_out=logtostderr=true:./generated</code> to generate gateway code. It will place at <code>go_package</code> path</li><li>Add <code>--grpc-swagger_out=logtostderr=true:.</code> to generate Swagger definitions. It will place it in the same folder as the proto file.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#960050;background-color:#1e0010>protoc</span> <span style=color:#960050;background-color:#1e0010>-I.</span> <span style=color:#960050;background-color:#1e0010>\</span>
  <span style=color:#960050;background-color:#1e0010>-I</span><span style=color:#66d9ef>$(</span>GOPATH<span style=color:#66d9ef>)</span><span style=color:#960050;background-color:#1e0010>/src</span> <span style=color:#960050;background-color:#1e0010>\</span>
  <span style=color:#960050;background-color:#1e0010>-I</span><span style=color:#66d9ef>$(</span>GOPATH<span style=color:#66d9ef>)</span><span style=color:#960050;background-color:#1e0010>/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis</span> <span style=color:#960050;background-color:#1e0010>\</span>
  --grpc-gateway_out<span style=color:#f92672>=</span>logtostderr<span style=color:#f92672>=</span>true:./generated <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --swagger_out<span style=color:#f92672>=</span>logtostderr<span style=color:#f92672>=</span>true:. <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  --go_out<span style=color:#f92672>=</span>plugins<span style=color:#f92672>=</span>grpc:./generated <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>  api/api.proto
</code></pre></div><p>After running <code>protoc</code>, the reverse-proxy code will be available for use. It is just a matter of creating an HTTP server for it. The following implementation is running it in a separate server.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// File: cmd/gateway/main.go
</span><span style=color:#75715e></span>
<span style=color:#75715e>// Note: Make sure the gRPC server is running properly and accessible
</span><span style=color:#75715e></span>
<span style=color:#a6e22e>mux</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>NewServeMux</span>()
<span style=color:#a6e22e>opts</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>DialOption</span>{<span style=color:#a6e22e>grpc</span>.<span style=color:#a6e22e>WithInsecure</span>()}

<span style=color:#75715e>// Register gRPC server endpoint
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>api</span>.<span style=color:#a6e22e>RegisterIdentityHandlerFromEndpoint</span>(
  <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(), <span style=color:#a6e22e>mux</span>, <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;grpc-address&#34;</span>), <span style=color:#a6e22e>opts</span>)
); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
}

<span style=color:#75715e>// Start HTTP reverse proxy: sends calls to GRPC server
</span><span style=color:#75715e></span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>String</span>(<span style=color:#e6db74>&#34;gateway-address&#34;</span>), <span style=color:#a6e22e>mux</span>)
</code></pre></div><p>Any REST client should be able to request data from the Gateway. Server up, this is curl&rsquo;s output:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>â  ~ curl localhost:8080/v1/users
<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;users&#34;</span>:<span style=color:#f92672>[{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;xyz&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Pelican Steve&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}</span>,<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;foo&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;John Doe&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}</span>,<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;bar&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Chauffina Carr&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}]}</span>
â  ~ curl localhost:8080/v1/users/xyz
<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user&#34;</span>:<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;user_id&#34;</span>:<span style=color:#e6db74>&#34;xyz&#34;</span>,<span style=color:#e6db74>&#34;name&#34;</span>:<span style=color:#e6db74>&#34;Pelican Steve&#34;</span>,<span style=color:#e6db74>&#34;active&#34;</span>:true<span style=color:#f92672>}}</span>
â  ~ curl localhost:8080/v1/users/aaa
<span style=color:#f92672>{</span><span style=color:#e6db74>&#34;error&#34;</span>:<span style=color:#e6db74>&#34;resource was not found&#34;</span>,<span style=color:#e6db74>&#34;code&#34;</span>:5,<span style=color:#e6db74>&#34;message&#34;</span>:<span style=color:#e6db74>&#34;resource was not found&#34;</span><span style=color:#f92672>}</span>%
</code></pre></div><p>Magic, isn&rsquo;t it? Having this REST set-up might put a smile on some faces. The service can be migrated to GRPC for internal usage, keeping compatibility with REST clients &ndash; third-parties, non-techies and front-end applications.</p><p><a href=https://www.gophercon.co.uk/videos/2019/writing-rest-services-for-the-grpc-curious/>There is an excellent talk</a> by Johan Brandhorst giving more details on GRPC Gateway.</p><p><em><a href=https://github.com/brunoluiz/grpc-example/pull/1>Code of this part available at Github brunoluiz/grpc-example@with-gateway</a></em></p><h1 id=fantastic-debugging-tools-and-where-to-find-them>Fantastic debugging tools and where to find them</h1><p>Sooner or later, a quick peek into the service will be required, for debugging or scriptting purposes. In REST this can be done through tools such as curl, Insomnia or Postman. In GRPC, a different set of tools is required.</p><p>For the Graphical Interface lovers, the most popular one is <a href=https://github.com/uw-labs/bloomrpc>BloomRPC</a>. It only requires the proto files to be loaded and then it works similarly to any other REST client.</p><p><img loading=lazy src=https://github.com/uw-labs/bloomrpc/raw/873953c6b00906a69f165c332634b946c7724fe9/resources/editor-preview.gif alt="BloomRPC demo"></p><p>For mouse avoiders &ndash; or terminal lovers ð &ndash; there are two quite useful tools. <a href=https://github.com/fullstorydev/grpcurl>GRPCurl</a> is an awesome CLI tool, resembling curl and allow easy GRPC automation and scripting. A simple example of its usage follows:</p><p><code>grpcurl --plaintext --proto api/api.proto localhost:5000 api.Identity/GetUsers</code></p><p><a href=https://github.com/ktr0731/evans>Evans</a> goes a little bit further, as it has a REPL mode as well, allowing easier resource inspections (my favourite).</p><p><img loading=lazy src=https://github.com/ktr0731/evans/raw/97d1de81aa4ea471a14f4db56bf04830c6d79c39/evans1.gif alt="Evan REPL Demo"></p><p>These tools, GUI or not, are quite useful while testing and inspecting GRPC services. Try them and find the one which fits your needs better ð</p><h1 id=my-experience-using-it>My experience using it</h1><p>In my workplace GRPC has proved quite useful for connecting services, especially internal ones. Protocol Buffers came to be our main IDL when defining contracts for APIs and Stream Events. Due to these contracts, communicating implementations and changes are easier.</p><p>Implementing service clients and servers had been easier and faster. The most common issue is due to include paths errors, which sometimes get messy. But this is more due to our learnings around it than the technology itself. Some of the boilerplate, such as registering the server or dialing the client, can be tackled by creating custom protoc plugins. This proved quite useful, specially when the team is more product-oriented.</p><p>For Golang, it proved to work quite well in most cases, with good community support. But, <code>protoc</code> can generate code to other languages as well, such as NodeJS and Java. Although, in our NodeJS services, we felt GRPC support is still lacking behind Golang.</p><p>In general, GRPC has been a good choice for our services. Hopefully, it will be good for your team as well.</p></div><footer class=post-footer></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://brunoluiz.net>Bruno Luiz Silva</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugoï¸ï¸</a>ï¸</span>
<span>&#183;</span>
<span>Themeï¸ <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top"><button class=top-link id=top-link type=button><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6"><path d="M12 6H0l6-6z"/></svg></button></a>
<script src=https://brunoluiz.net/js/highlight.min.min.e7afc2928c0925d65c4732dfebe147014d91299a98e819e4b42f25c4fa68e91c.js integrity="sha256-56/CkowJJdZcRzLf6+FHAU2RKZqY6BnktC8lxPpo6Rw="></script><script>hljs.initHighlightingOnLoad();</script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();document.querySelector(this.getAttribute("href")).scrollIntoView({behavior:"smooth"});});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script><script data-goatcounter=https://brunoluiz.goatcounter.com/count async src=//gc.zgo.at/count.js></script></body></html>