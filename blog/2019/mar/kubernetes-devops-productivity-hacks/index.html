<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kubernetes devops productivity hacks | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as kubectl. But how do we go beyond kubectl?"><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="Kubernetes devops productivity hacks"><meta property="og:description" content="Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as kubectl. But how do we go beyond kubectl?"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-03-14T21:37:37+00:00"><meta property="article:modified_time" content="2019-03-14T21:37:37+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="Kubernetes devops productivity hacks"><meta name=twitter:description content="Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as kubectl. But how do we go beyond kubectl?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"Kubernetes devops productivity hacks","item":"https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kubernetes devops productivity hacks","name":"Kubernetes devops productivity hacks","description":"Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as kubectl. But how do we go beyond kubectl?","keywords":[],"articleBody":"Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as kubectl.\nAfter some point though, using kubectl for everything can get quite verbose, especially if you use many namespaces and contexts. The following tips try to minimise the pain of doing operations solely through it, sometimes even using other tools beside it.\nKubectx: context and namespaces management Operations done in kubectl usually require two params: context and namespace. Any operation will result in something as kubectl --context dev --namespace hello-world exec -it hello-world-app-0 sh. It is fine for a one-time operation, but after some point, it can get quite cumbersome. One way to avoid these long command strings is by using kubectx.\nAfter installing it, the context can be set by simply using kubectx dev and the namespace as kubens hello-world. To list the available contexts and namespaces, just run it without arguments. The above operation can be run by only using kubectl exec -it hello-world-app-0 sh.\nTerminal aliases Seasoned Unix developers are quite used to terminal aliases. Some are quite popular that are even grouped in packs, such as oh-my-zsh git aliases. With Kubernetes is not that different.\nUsually, having alias k=\"kubectl\" already make operations shorter. Using the same example, it would result in k exec -it hello-world-app-0 sh. But, most likely, one alias will not be enough. There are some options for this.\nThe first one can be set-up in any terminal emulator (zsh, bashâ€¦). Get the .kubectl_aliases file from ahmetb/kubectl-aliases and place it in your home directory. After sourcing it on .zshrc or .bashrc, 600 aliases will be available out-of-box, including the aforementioned k.\n[ -f ~/.kubectl_aliases ] \u0026\u0026 source ~/.kubectl_aliases If zsh and oh-my-zsh are already set-up, an easier option would be to use the pre-installed kubectl plugin. To enable it, edit your .zshrc and add kubectl to the plugins variable (more details about oh-my-zsh plugins here).\nplugins=(git kubectl ...) There are fewer aliases compared to ahmetb/kubectl-aliases, making it easier to learn and faster to load. The list of oh-my-zsh/kubectl aliases is available here\nkubectx and kubens do not have aliases by default. To allow shorter calls for it, place the following on .zshrc or .bashrc.\nalias kns=\"kubens\" alias kcx=\"kubectx\" After all these aliases been set-up, the hello-world-app-0 sh can be accessed using a simple keti hello-world-app-0 sh. As games, it will be as learning combat combos, although it will not be as close as a Hadouken combo.\nTerminal namespace and context indicator Developers are humans (in case you did not know) and humans do not have bulletproof memory. One can forget that kubernetes context is set to production and then run kubectl apply there, instead of dev.\nTo avoid this, an indicator can be used in the terminal to show what is the actual context and namespace. The easiest way to do it is by using kube-ps1. It already comes with oh-my-zsh, requiring kube-ps1 to be added to .zshrc plugins variable.\nAfter installing or enabling it, the PS1 needs to be changed to include the kubectl context and namespace information. This can be easily done by adding export PS1='$(kube_ps1) '$PS1 to your .bashrc/.zshrc file. The final result will be something like the following.\nThe only issue with kube-ps1 is, when used with git plugin in zsh, it can generate really long PS1 strings. If tmux is used, it can be actually set-up in the status bar through kube-tmux plugin, avoiding PS1 cluttering.\nInvestigating logs: the sane way Failures can happen, debugs are required and check-ups are sometimes necessary. For all of these, application logs are needed. The standard way to open them is:\nkubectl --namespace dev --context labs get pods # get the pod id kubectl --namespace dev --context labs logs -f If the pod is killed and restarted, the process has to be repeated as the pod id will change. Besides, the kubectl logs tool is quite simple in terms of features. stern is meant to be more powerful and allows to tail multiple pods and containers at once (even the whole namespace, if required).\nTo tail pods, such as the hello-world example, stern hello-world will do. It would tail everything using the *hello-world* as an expression. If multiple pods were been run, it would log all hello-world pods.\nstern hello-world # tail all pods containing \"hello-world\" in its name stern . # tail all pods in current namespace stern --since 1h . # tail logs from last one hour Shorter calls can be done setting up an alias, such as alias s='stern'. If set, it uses the kubectx and kubens settings, while accepting --namespace and --context args as well.\nAutomatic deployments A way to avoid touching prod environment using kubectl is by setting up kube-applier. This service auto-deploy changes on infrastructure changes, based on a git repository.\nIt runs as a separate pod, watching and comparing kubernetes manifest repository with deployed services. If there is a difference between manifests, it will automatically apply what is in the git repository, making it the source of truth for kube manifests.\nAfter installing kube-applier, no deploys should be done through kubectl, as it will always revert to git manifests. This avoids confusions around deployments made in a rush, not merged and then rollbacked by a mistake.\nAdd safety against wrong kubectl apply If kube-applier is not an option, perhaps it would be good to have a protection before kubectl apply operations. There are many ways to do this, the following considers overwriting kaf from oh-my-zsh plugin. It adds a confirmation prompt and shows which context it will be applied to.\n# Confirm command to be executed confirm() { echo -n \"\\e[33mDo you want to run $*? [N/yes] \\e[m\" read REPLY # if test \"$REPLY\" = \"y\" -o \"$REPLY\" = \"Y\"; then if test \"$REPLY\" = \"yes\"; then \"$@\" else echo \"Cancelled by user\" fi } safe_kubectlapply() { context=$(kubectl config current-context) echo \"\\n\" echo \"BECAREFUL!!! APPLYING TO \\e[31m$context\\e[m\" confirm kubectl apply -f \"$@\" } alias kaf='safe_kubectlapply' This can pottentially save lifes. It can be modified to be used with other operations, such as kdel and kdelf (aliases for kubectl delete).\nConclusion These are just some tricks I use in my daily kubernetes life. Have a good coding week! ðŸ˜‰\nReferences Cover photo by Cameron Venti on Unsplash kubectx repo ahmetb/kubectl-aliases repo oh-my-zsh repo oh-my-zsh kubectl info kube-ps1 repo oh-my-zsh kube-ps1 info kube-tmux repo stern repo kube-applier repo ","wordCount":"1075","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2019-03-14T21:37:37.121Z","dateModified":"2019-03-14T21:37:37.121Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Kubernetes devops productivity hacks</h1><div class=post-meta><span title='2019-03-14 21:37:37.121 +0000 UTC'>March 14, 2019</span>&nbsp;Â·&nbsp;6 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover_hu_ba22d964847ee276.jpg 360w,https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover_hu_7ce946ef2dc89368.jpg 480w,https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover_hu_d076480d39453b42.jpg 720w,https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover_hu_65477737f2b3bf78.jpg 1080w,https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover_hu_2cd76e8bfac137.jpg 1500w,https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover.jpg 3985w' src=https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=3985 height=2250 alt="Photo by Cameron Venti on Unsplash"><figcaption>Photo by Cameron Venti on Unsplash</figcaption></figure><div class=post-content><p>Today, Kubernetes is the de facto container orchestration solution. Together with the devops culture, developers have to get familiarised to its tools, such as <code>kubectl</code>.</p><p>After some point though, using <code>kubectl</code> for everything can get quite verbose, especially if you use many namespaces and contexts. The following tips try to minimise the pain of doing operations solely through it, sometimes even using other tools beside it.</p><h2 id=kubectx-context-and-namespaces-management>Kubectx: context and namespaces management<a hidden class=anchor aria-hidden=true href=#kubectx-context-and-namespaces-management>#</a></h2><p>Operations done in <code>kubectl</code> usually require two params: <strong>context</strong> and <strong>namespace</strong>. Any operation will result in something as <code>kubectl --context dev --namespace hello-world exec -it hello-world-app-0 sh</code>. It is fine for a one-time operation, but after some point, it can get quite cumbersome. One way to avoid these long command strings is by using <a href=https://github.com/ahmetb/kubectx><code>kubectx</code></a>.</p><p>After installing it, the context can be set by simply using <code>kubectx dev</code> and the namespace as <code>kubens hello-world</code>. To list the available contexts and namespaces, just run it without arguments. The above operation can be run by only using <code>kubectl exec -it hello-world-app-0 sh</code>.</p><h2 id=terminal-aliases>Terminal aliases<a hidden class=anchor aria-hidden=true href=#terminal-aliases>#</a></h2><p>Seasoned Unix developers are quite used to terminal aliases. Some are quite popular that are even grouped in packs, such as <a href=https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh>oh-my-zsh git aliases</a>. With Kubernetes is not that different.</p><p>Usually, having <code>alias k="kubectl"</code> already make operations shorter. Using the same example, it would result in <code>k exec -it hello-world-app-0 sh</code>. But, most likely, one alias will not be enough. There are some options for this.</p><p>The first one can be set-up in any terminal emulator (<code>zsh</code>, <code>bash</code>&mldr;). Get the <code>.kubectl_aliases</code> file from <a href=https://github.com/ahmetb/kubectl-aliases><code>ahmetb/kubectl-aliases</code></a> and place it in your home directory. After sourcing it on <code>.zshrc</code> or <code>.bashrc</code>, 600 aliases will be available out-of-box, including the aforementioned <code>k</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#f92672>[</span> -f ~/.kubectl_aliases <span style=color:#f92672>]</span> <span style=color:#f92672>&amp;&amp;</span> source ~/.kubectl_aliases
</span></span></code></pre></div><p>If <a href=http://zsh.sourceforge.net/><code>zsh</code></a> and <a href=https://ohmyz.sh/><code>oh-my-zsh</code></a> are already set-up, an easier option would be to use the pre-installed <code>kubectl</code> plugin. To enable it, edit your <code>.zshrc</code> and add <code>kubectl</code> to the <code>plugins</code> variable (<a href=https://github.com/robbyrussell/oh-my-zsh#plugins>more details about oh-my-zsh plugins here</a>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>plugins<span style=color:#f92672>=(</span>git kubectl ...<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>There are fewer aliases compared to <code>ahmetb/kubectl-aliases</code>, making it easier to learn and faster to load. The list of <code>oh-my-zsh/kubectl</code> aliases is <a href=https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/kubectl>available here</a></p><p><code>kubectx</code> and <code>kubens</code> do not have aliases by default. To allow shorter calls for it, place the following on <code>.zshrc</code> or <code>.bashrc</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>alias kns<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;kubens&#34;</span>
</span></span><span style=display:flex><span>alias kcx<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;kubectx&#34;</span>
</span></span></code></pre></div><p>After all these aliases been set-up, the <code>hello-world-app-0 sh</code> can be accessed using a simple <code>keti hello-world-app-0 sh</code>. As games, it will be as learning combat combos, although it will not be as close as a Hadouken combo.</p><h2 id=terminal-namespace-and-context-indicator>Terminal namespace and context indicator<a hidden class=anchor aria-hidden=true href=#terminal-namespace-and-context-indicator>#</a></h2><p>Developers are humans (in case you did not know) and humans do not have bulletproof memory. One can forget that kubernetes context is set to production and then run <code>kubectl apply</code> there, instead of dev.</p><p>To avoid this, an indicator can be used in the terminal to show what is the actual context and namespace. The easiest way to do it is by using <a href=https://github.com/jonmosco/kube-ps1><code>kube-ps1</code></a>. It already comes with <code>oh-my-zsh</code>, requiring <code>kube-ps1</code> to be added to <code>.zshrc</code> plugins variable.</p><p>After installing or enabling it, the PS1 needs to be changed to include the kubectl context and namespace information. This can be easily done by adding <code>export PS1='$(kube_ps1) '$PS1</code> to your <code>.bashrc/.zshrc</code> file. The final result will be something like the following.</p><p><img alt="kube-ps1 example" loading=lazy src=/blog/2019/mar/kubernetes-devops-productivity-hacks/kube-ps1.png></p><p>The only issue with <code>kube-ps1</code> is, when used with <code>git</code> plugin in zsh, it can generate really long PS1 strings. If <code>tmux</code> is used, it can be actually set-up in the status bar through <a href=https://github.com/jonmosco/kube-tmux><code>kube-tmux</code></a> plugin, avoiding PS1 cluttering.</p><p><img alt="kube-tmux example" loading=lazy src=/blog/2019/mar/kubernetes-devops-productivity-hacks/kube-tmux-ps1.png></p><h2 id=investigating-logs-the-sane-way>Investigating logs: the sane way<a hidden class=anchor aria-hidden=true href=#investigating-logs-the-sane-way>#</a></h2><p>Failures can happen, debugs are required and check-ups are sometimes necessary. For all of these, application logs are needed. The standard way to open them is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --namespace dev --context labs get pods
</span></span><span style=display:flex><span><span style=color:#75715e># get the pod id</span>
</span></span><span style=display:flex><span>kubectl --namespace dev --context labs logs &lt;pod-id&gt; -f
</span></span></code></pre></div><p>If the pod is killed and restarted, the process has to be repeated as the pod id will change. Besides, the <code>kubectl</code> logs tool is quite simple in terms of features. <a href=https://github.com/wercker/stern><code>stern</code></a> is meant to be more powerful and allows to tail multiple pods and containers at once (even the whole namespace, if required).</p><p>To tail pods, such as the hello-world example, <code>stern hello-world</code> will do. It would tail everything using the <code>*hello-world*</code> as an expression. If multiple pods were been run, it would log all hello-world pods.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>stern hello-world  <span style=color:#75715e># tail all pods containing &#34;hello-world&#34; in its name</span>
</span></span><span style=display:flex><span>stern .            <span style=color:#75715e># tail all pods in current namespace</span>
</span></span><span style=display:flex><span>stern --since 1h . <span style=color:#75715e># tail logs from last one hour</span>
</span></span></code></pre></div><p>Shorter calls can be done setting up an alias, such as <code>alias s='stern'</code>. If set, it uses the <code>kubectx</code> and <code>kubens</code> settings, while accepting <code>--namespace</code> and <code>--context</code> args as well.</p><h2 id=automatic-deployments>Automatic deployments<a hidden class=anchor aria-hidden=true href=#automatic-deployments>#</a></h2><p>A way to avoid touching prod environment using <code>kubectl</code> is by setting up <a href=https://github.com/box/kube-applier><code>kube-applier</code></a>. This service auto-deploy changes on infrastructure changes, based on a git repository.</p><p>It runs as a separate pod, watching and comparing kubernetes manifest repository with deployed services. If there is a difference between manifests, it will automatically apply what is in the git repository, making it the source of truth for kube manifests.</p><p>After installing <code>kube-applier</code>, no deploys should be done through <code>kubectl</code>, as it will always revert to git manifests. This avoids confusions around deployments made in a rush, not merged and then rollbacked by a mistake.</p><h2 id=add-safety-against-wrong-kubectl-apply>Add safety against wrong kubectl apply<a hidden class=anchor aria-hidden=true href=#add-safety-against-wrong-kubectl-apply>#</a></h2><p>If <code>kube-applier</code> is not an option, perhaps it would be good to have a protection before <code>kubectl apply</code> operations. There are many ways to do this, the following considers overwriting <code>kaf</code> from <code>oh-my-zsh</code> plugin. It adds a confirmation prompt and shows which context it will be applied to.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># Confirm command to be executed</span>
</span></span><span style=display:flex><span>confirm<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  echo -n <span style=color:#e6db74>&#34;\e[33mDo you want to run </span>$*<span style=color:#e6db74>? [N/yes] \e[m&#34;</span>
</span></span><span style=display:flex><span>  read REPLY
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># if test &#34;$REPLY&#34; = &#34;y&#34; -o &#34;$REPLY&#34; = &#34;Y&#34;; then</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> test <span style=color:#e6db74>&#34;</span>$REPLY<span style=color:#e6db74>&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;yes&#34;</span>; <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      echo <span style=color:#e6db74>&#34;Cancelled by user&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>fi</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>safe_kubectlapply<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  context<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>kubectl config current-context<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;\n&#34;</span>
</span></span><span style=display:flex><span>  echo <span style=color:#e6db74>&#34;BECAREFUL!!! APPLYING TO \e[31m</span>$context<span style=color:#e6db74>\e[m&#34;</span>
</span></span><span style=display:flex><span>  confirm kubectl apply -f <span style=color:#e6db74>&#34;</span>$@<span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alias kaf<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;safe_kubectlapply&#39;</span>
</span></span></code></pre></div><p>This can pottentially save lifes. It can be modified to be used with other operations, such as <code>kdel</code> and <code>kdelf</code> (aliases for <code>kubectl delete</code>).</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>These are just some tricks I use in my daily kubernetes life. Have a good coding week! ðŸ˜‰</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ul><li>Cover photo by <a href="https://unsplash.com/photos/QtETdXXR7gs?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Cameron Venti</a> on Unsplash</li><li><a href=https://github.com/ahmetb/kubectx><code>kubectx</code> repo</a></li><li><a href=https://github.com/ahmetb/kubectl-aliases><code>ahmetb/kubectl-aliases</code> repo</a></li><li><a href=https://github.com/robbyrussell/oh-my-zsh><code>oh-my-zsh</code> repo</a></li><li><a href=https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/kubectl><code>oh-my-zsh</code> kubectl info</a></li><li><a href=https://github.com/jonmosco/kube-ps1><code>kube-ps1</code> repo</a></li><li><a href=https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins/kube-ps1><code>oh-my-zsh</code> kube-ps1 info</a></li><li><a href=https://github.com/jonmosco/kube-tmux><code>kube-tmux</code> repo</a></li><li><a href=https://github.com/wercker/stern><code>stern</code> repo</a></li><li><a href=https://github.com/box/kube-applier><code>kube-applier</code> repo</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/graphql-as-a-gateway/><span class=title>Â« Prev</span><br><span>GraphQL feat API Gateway</span>
</a><a class=next href=https://brunoluiz.net/blog/2019/feb/a-guide-to-npm-package-publishing/><span class=title>Next Â»</span><br><span>A guide on npm package publishing</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>