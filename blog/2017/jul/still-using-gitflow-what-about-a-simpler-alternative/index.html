<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Still using GitFlow? What about a simpler alternative? | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="GitFlow is a branching model created by Vincent Driessen on 2010. Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow."><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="Still using GitFlow? What about a simpler alternative?"><meta property="og:description" content="GitFlow is a branching model created by Vincent Driessen on 2010. Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2017-07-18T19:44:37+00:00"><meta property="article:modified_time" content="2017-07-18T19:44:37+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="Still using GitFlow? What about a simpler alternative?"><meta name=twitter:description content="GitFlow is a branching model created by Vincent Driessen on 2010. Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"Still using GitFlow? What about a simpler alternative?","item":"https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Still using GitFlow? What about a simpler alternative?","name":"Still using GitFlow? What about a simpler alternative?","description":"GitFlow is a branching model created by Vincent Driessen on 2010. Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow.","keywords":[],"articleBody":"GitFlow is a branching model created by Vincent Driessen on 2010 (original article). Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow. Some of the discussed reasons of why not go with GitFlow are the same written on this blog post.\nThe Feature Branch Model Compared to GitFlow, it is easier to implement and does not require any plugins to be properly used. The step-by-step of this model would be:\nCreate a branch from the master (feature-x), which is where the feature will be developed: git checkout -b feature-x\nPush the branch to the remote: git push -u origin feature-x. With the branch in the remote repo, a pull request should be opened with it (How to open it in GitHub). A pull request is where all modifications are available to other members and they will be able to review it\nFix the reviewed code and wait for approval. If a new release on the master generates a conflict, a best practice would be to rebase it (instead of merging)\n(optional) If a rebase is needed: checkout to master git checkout master, pull the changes git pull, go back to the feature branch git checkout feature-x, do the rebase git rebase master and then sync the rebased branch git push --force-with-lease. A good tutorial about merging x rebasing is available on this Atlassian article.\nIf there are no conflicts and it was approved ⇒ squash + merge\nThis Atlassian article have a more detailed view on the feature branch model\nWhy Squash + Merge instead of just Merge? The squash and merge is made up of two processes: the squash, which compact all commits in one big commit/patch, and then the merge itself. After squashing + merging, you will have only one commit in the target branch (usually master) containing all your modifications. This enables two things:\nIt is easier to move this feature, as the whole patch/feature will be on one commit hash\nThe target branch will be cleaner, less messy and more readable — without those 67 commits you have made to finish the feature.\nThere are more information about about why devs prefers squash and merge, instead of only merging, on this article.\nManaging release versions with git tags In the feature branch model, a merge is considered a new version release. To track each release version, tags can be used. These will be used as reference to choose which version should be deployed at the servers.\nTo manage these tags/release, a good practice is the usage of *semantic versioning:*\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. The process to create the releases can be automated using grunt-release or gulp-release-tasks. But, following the steps bellow, it can be easily done by hand:\nCheckout to the master branch: git checkout master\nPull changes from the remote git pull\nGet the most recent tag using git describe --abbrev=0 (let’s say it returns v0.1.0)\nCreate a tag using git tag -a ⇒git tag -a v0.2.0\nPush the modifications and the tag: git push origin v0.2.0 --follow-tags\nDone!\nDeploying In many PaaS, such as AWS Beanstalk or Heroku, a remote repository is set-up where, when changes are pushed (eg. git push heroku master), a deploy is triggered using the latest commits on master. In these cases, a simple push force using the release tag will deploy the desired version: git push -f v0.2.0:master. Easy, eh?\nNOTE: At Chaordic New Offers Team, a grunt script was developed where we publish which tag should be deployed: grunt deploy:::all\nWhat happens if a hot-fix is needed? At some point, an issue will be raised and the production version will need a hot-fix ASAP. A feature branch can’t just be opened to develop a fix, as the master will probably be ahead of the production version. In this case, the fix needs to be done directly on the production version:\nCheckout to the production version tag git checkout v0.10.0\nCreate a new branch from this tag git checkout -b hotfix-v0.10.1-weirdbehavior\nCreate the fix and commit it\nCreate a tag for this new release git tag -a v0.10.1 (notice the SEMVER pattern)\nPush the branch and tag to remote git push -u origin hotfix-v0.10.1-weirdbehavior --follow-tags\nDeploy the tag v0.10.1 to the production environment\nA push request should be opened, as the fix should be applied at the master afterwards\nIf more patches are needed, this process can be repeated on the same version, incrementing only the patch version.\nWhat about applying it to other environments? This patch probably should be applied to other environments as well, which can be done through git cherry-pick . It basically applies the chosen commit to the actual HEAD.\nCheckout to the environment version tag git checkout v0.13.0\nCreate a new branch for the patch git checkout -b hotfix-v0.13.1\nDo a git cherry-pick v0.10.1 or a git cherry-pick to apply the desired commit\ngit tag -a v0.13.1 and git push origin v0.13.1 (push just the tag)\nDeploy it\nWhat if I want to get a modification from master and sent to one of the environments? It is very similar to the above one: a git cherry-pick should be done using a commit hash from the master as, after squash + merge a push request, a new commit is generated with all changes (big patch of commits condensed in one).\nJust keep in mind… The gap between the environments versions should be as short as possible. Otherwise, some issues may appear:\nIf the production is on v0.1.10, the latest release is v0.10, but the version v0.3 will be deployed: the team members will have to check if some of the production patches are still required and then apply them, one by one.\nIf some feature was only finished on v0.10.0, and it is required for the roll-out, but the v0.7.0 is still not well tested: the release should be hold until the v0.7.0 has been tested\nUsually, these version gaps occur when the producing capacity is higher than the testing capacity (developers x testers ratio).\nConclusion The model is still being tested but, until now, it has been working well. The only faced drawbacks were the ones pointed on the session above.\n","wordCount":"1100","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2017-07-18T19:44:37.121Z","dateModified":"2017-07-18T19:44:37.121Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Still using GitFlow? What about a simpler alternative?</h1><div class=post-meta><span title='2017-07-18 19:44:37.121 +0000 UTC'>July 18, 2017</span>&nbsp;·&nbsp;6 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover_hu_1d12ac975ce299bb.jpg 360w,https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover_hu_18ac8f48cf62608c.jpg 480w,https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover_hu_425e86b968095202.jpg 720w,https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover_hu_8110b788967ac132.jpg 1080w,https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover_hu_541407079e97429b.jpg 1500w,https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover.jpg 2000w' src=https://brunoluiz.net/blog/2017/jul/still-using-gitflow-what-about-a-simpler-alternative/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=2000 height=1333 alt="Alternative on sight"><figcaption>Alternative on sight</figcaption></figure><div class=post-content><p>GitFlow is a branching model created by Vincent Driessen on 2010 (<a href=http://nvie.com/posts/a-successful-git-branching-model/>original article</a>). Since it was published, many companies had tested and implemented it, which allows us to have many reviews about how well (or not) it works. After some discussions within our team, we decided to not go with GitFlow, but use a simpler model instead, together with a tightly defined workflow. Some of the discussed reasons of why not go with GitFlow are the same written on <a href=http://endoflineblog.com/gitflow-considered-harmful>this blog post</a>.</p><h2 id=the-feature-branch-model>The Feature Branch Model<a hidden class=anchor aria-hidden=true href=#the-feature-branch-model>#</a></h2><p>Compared to GitFlow, it is easier to implement and does not require any plugins to be properly used. The step-by-step of this model would be:</p><ol><li><p>Create a branch from the master (feature-x), which is where the feature will be developed: <code>git checkout -b feature-x</code></p></li><li><p>Push the branch to the remote: <code>git push -u origin feature-x</code>. With the branch in the remote repo, a pull request should be opened with it (<a href=https://help.github.com/articles/creating-a-pull-request/>How to open it in GitHub</a>). A pull request is where all modifications are available to other members and they will be able to review it</p></li><li><p>Fix the reviewed code and wait for approval. If a new release on the master generates a conflict, a best practice would be to rebase it (instead of merging)</p></li><li><p>(optional) If a rebase is needed: checkout to master <code>git checkout master</code>, pull the changes <code>git pull</code>, go back to the feature branch <code>git checkout feature-x</code>, do the rebase <code>git rebase master</code> and then sync the rebased branch <code>git push --force-with-lease</code>. <a href=https://www.atlassian.com/git/tutorials/merging-vs-rebasing>A good tutorial about merging x rebasing is available on this Atlassian article</a>.</p></li><li><p>If there are no conflicts and it was approved ⇒ <strong>squash + merge</strong></p></li></ol><p><a href=https://www.atlassian.com/git/tutorials/comparing-workflows#feature-branch-workflow>This Atlassian article have a more detailed view on the feature branch model</a></p><h3 id=why-squash--merge-instead-of-just-merge>Why Squash + Merge instead of just Merge?<a hidden class=anchor aria-hidden=true href=#why-squash--merge-instead-of-just-merge>#</a></h3><p>The squash and merge is made up of two processes: the squash, which compact all commits in one big commit/patch, and then the merge itself. After squashing + merging, you will have only one commit in the target branch (usually master) containing all your modifications. This enables two things:</p><ol><li><p>It is easier to move this feature, as the whole patch/feature will be on one commit hash</p></li><li><p>The target branch will be cleaner, less messy and more readable — without those 67 commits you have made to finish the feature.</p></li></ol><p>There are more information about <a href=https://softwareengineering.stackexchange.com/questions/263164/why-squash-git-commits-for-pull-requests>about why devs prefers squash and merge, instead of only merging, on this article</a>.</p><h2 id=managing-release-versions-with-git-tags>Managing release versions with git tags<a hidden class=anchor aria-hidden=true href=#managing-release-versions-with-git-tags>#</a></h2><p>In the feature branch model, a merge is considered a new version release. To track each release version, tags can be used. These will be used as reference to choose which version should be deployed at the servers.</p><p>To manage these tags/release, a good practice is the usage of <a href=http://semver.org>*semantic versioning</a>:*</p><blockquote><p>Given a version number <strong>MAJOR.MINOR.PATCH</strong>, increment the:</p><ol><li>MAJOR version when you make incompatible API changes,</li><li>MINOR version when you add functionality in a backwards-compatible manner, and</li><li>PATCH version when you make backwards-compatible bug fixes.</li></ol></blockquote><p>The process to create the releases can be automated using <a href=https://github.com/geddski/grunt-release><code>grunt-release</code></a> or <a href=https://github.com/lfender6445/gulp-release-tasks><code>gulp-release-tasks</code></a>. But, following the steps bellow, it can be easily done by hand:</p><ol><li><p>Checkout to the master branch: <code>git checkout master</code></p></li><li><p>Pull changes from the remote <code>git pull</code></p></li><li><p>Get the most recent tag using <code>git describe --abbrev=0</code> (let&rsquo;s say it returns v0.1.0)</p></li><li><p>Create a tag using <code>git tag -a &lt;version></code>⇒<code>git tag -a v0.2.0</code></p></li><li><p>Push the modifications and the tag: <code>git push origin v0.2.0 --follow-tags</code></p></li><li><p>Done!</p></li></ol><h2 id=deploying>Deploying<a hidden class=anchor aria-hidden=true href=#deploying>#</a></h2><p>In many PaaS, such as AWS Beanstalk or Heroku, a remote repository is set-up where, when changes are pushed (eg. git push heroku master), a deploy is triggered using the latest commits on master. In these cases, a simple push force using the release tag will deploy the desired version: <code>git push -f &lt;deploy/env-remote> v0.2.0:master</code>. Easy, eh?</p><blockquote><p>NOTE: At Chaordic New Offers Team, a grunt script was developed where we publish which tag should be deployed: <code>grunt deploy:&lt;version>:&lt;env>:all</code></p></blockquote><h2 id=what-happens-if-a-hot-fix-is-needed>What happens if a hot-fix is needed?<a hidden class=anchor aria-hidden=true href=#what-happens-if-a-hot-fix-is-needed>#</a></h2><p>At some point, an issue will be raised and the production version will need a hot-fix <em>ASAP</em>. A feature branch can&rsquo;t just be opened to develop a fix, as the master will probably be ahead of the production version. In this case, the fix needs to be done directly on the production version:</p><ol><li><p>Checkout to the production version tag <code>git checkout v0.10.0</code></p></li><li><p>Create a new branch from this tag <code>git checkout -b hotfix-v0.10.1-weirdbehavior</code></p></li><li><p>Create the fix and commit it</p></li><li><p>Create a tag for this new release <code>git tag -a v0.10.1</code> (notice the SEMVER pattern)</p></li><li><p>Push the branch and tag to remote <code>git push -u origin hotfix-v0.10.1-weirdbehavior --follow-tags</code></p></li><li><p>Deploy the tag <code>v0.10.1</code> to the production environment</p></li><li><p>A push request should be opened, as the fix should be applied at the master afterwards</p></li></ol><p>If more patches are needed, this process can be repeated on the same version, incrementing only the patch version.</p><h3 id=what-about-applying-it-to-other-environments>What about applying it to other environments?<a hidden class=anchor aria-hidden=true href=#what-about-applying-it-to-other-environments>#</a></h3><p>This patch probably should be applied to other environments as well, which can be done through <a href=http://think-like-a-git.net/sections/rebase-from-the-ground-up/cherry-picking-explained.html>git cherry-pick</a> <commit-hash>. It basically applies the chosen commit to the actual HEAD.</p><ol><li><p>Checkout to the environment version tag <code>git checkout v0.13.0</code></p></li><li><p>Create a new branch for the patch <code>git checkout -b hotfix-v0.13.1</code></p></li><li><p>Do a <code>git cherry-pick v0.10.1</code> or a <code>git cherry-pick &lt;commit-hash></code> to apply the desired commit</p></li><li><p><code>git tag -a v0.13.1</code> and <code>git push origin v0.13.1</code> (push just the tag)</p></li><li><p>Deploy it</p></li></ol><h3 id=what-if-i-want-to-get-a-modification-from-master-and-sent-to-one-of-the-environments>What if I want to get a modification from master and sent to one of the environments?<a hidden class=anchor aria-hidden=true href=#what-if-i-want-to-get-a-modification-from-master-and-sent-to-one-of-the-environments>#</a></h3><p>It is very similar to the above one: a <code>git cherry-pick</code> should be done using a commit hash from the master as, after <strong>squash + merge</strong> a push request, a new commit is generated with all changes (big patch of commits condensed in one).</p><h2 id=just-keep-in-mind>Just keep in mind…<a hidden class=anchor aria-hidden=true href=#just-keep-in-mind>#</a></h2><p>The gap between the environments versions should be as short as possible. Otherwise, some issues may appear:</p><ul><li><p>If the production is on <code>v0.1.10</code>, the latest release is <code>v0.10</code>, but the version <code>v0.3</code> will be deployed: the team members will have to check if some of the production patches are still required and then apply them, one by one.</p></li><li><p>If some feature was only finished on <code>v0.10.0</code>, and it is required for the roll-out, but the <code>v0.7.0</code> is still not well tested: the release should be hold until the <code>v0.7.0</code> has been tested</p></li></ul><p>Usually, these version gaps occur when the producing capacity is higher than the testing capacity (developers x testers ratio).</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>The model is still being tested but, until now, it has been working well. The only faced drawbacks were the ones pointed on the session above.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/2017/aug/joi-validate-input-and-define-databases-in-javascript/><span class=title>« Prev</span><br><span>Joi: validate input and define databases in JavaScript</span>
</a><a class=next href=https://brunoluiz.net/blog/2017/jun/are-you-using-git-push-force-oh-mate-you-are-doing-it-wrong/><span class=title>Next »</span><br><span>Are you using git push force? Oh mate, you are doing it wrong!</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>