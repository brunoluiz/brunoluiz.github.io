<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GraphQL feat API Gateway | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="GraphQL, REST, gRPC, Thrift&mldr; Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services."><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/graphql-as-a-gateway/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/graphql-as-a-gateway/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/graphql-as-a-gateway/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="GraphQL feat API Gateway"><meta property="og:description" content="GraphQL, REST, gRPC, Thriftâ€¦ Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-07-01T08:00:00+00:00"><meta property="article:modified_time" content="2019-07-01T08:00:00+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="GraphQL feat API Gateway"><meta name=twitter:description content="GraphQL, REST, gRPC, Thrift&mldr; Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"GraphQL feat API Gateway","item":"https://brunoluiz.net/blog/graphql-as-a-gateway/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GraphQL feat API Gateway","name":"GraphQL feat API Gateway","description":"GraphQL, REST, gRPC, Thrift\u0026hellip; Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services.","keywords":[],"articleBody":"GraphQL, REST, gRPC, Thriftâ€¦ Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services.\nAPI Gateway pattern â€“ a quick introduction Consider two services: A and B. How a client would be able to request its data? The easiest way would be to make a request to service A and then another to B, each pointing to a different host (eg: a.service/orders and b.service/users).\nAs the number of services grows, it is quite laborious to keep using this strategy. Since there could be too many services and requests to coordinate. To solve this, an API proxy can be used, where the client will request to only one service instead of multiple. This proxy will orchestrate where this request should go, glueing all services in one place.\nWhile proxies just forward requests, API Gateways encapsulate more of the applicationâ€™s internal architecture. Working as a Facade with some other responsibilities, such as:\nRequest/Response Transformation: requests made by a client can be reshaped before being sent to internal services, with the same applying to responses. Request routing: as a proxy, it routes requests to specific services, translating to other protocols if required. Composition: one request to the gateway can actually be mapped to multiple internal ones. Throttling: limit user requests up to a determined threshold. Security: protect some endpoints with some sort of authentication (JWT token, basic, API tokens etc). Metrics and Logs: as all requests would pass through it, many metrics and logs will be collected through this service. For more information on the API gateway pattern, take a look at Nginx micro-services article and on this Chris Richardson article.\nWhy GraphQL and not REST? GraphQL was initially developed by Facebook and was open-sourced in 2015. Many companies started using it for internal APIs, but some are already exposing it as its public API (eg: GitHub, Shopify, Yelp and Contentful).\nSchema validation and documentation With GraphQL, in contrast to from REST, a schema is always required, following GraphQL Foundation directives. This allows not only schema validation from day one, but documentation too. Typed languages can benefit from the schema and generate type definitions through it (eg: typescript graphql-code-generator).\ntype Query { \"\"\" Fetch posts by user, allowing custom filtering \"\"\" posts(input: PostQueryInput): [Post] } input PostQueryInput { categoryId: String } \"\"\" Post bla bla bla \"\"\" type Post { title: String categories: [Category] } type Category { name: String } In theory, the same could be done with REST by using OpenAPI/Swagger, especially for documentation but YAML, yikes. But, the code generation tools are not exactly the best and sometimes the schema validation does not work properly, requiring extra middleware and tweaks around it. As GraphQL is standardised in this sense, it doesnâ€™t suffer from these issues.\nOne endpoint to rule them all GraphQL only exposes one endpoint. Instead of having N client requests, only one is needed. The server orchestrates everything required to fulfil the whole request, such as: calling multiple micro-services (with any protocol), mapping outputs to the expected schema and logging requests/responses. Besides, this solves under-fetching issues.\nOut-of-box standards REST has been around for a long time, and during this period developers started to have specific necessities, such as sparse fieldsets, versioning, pagination. There are many ways to implement these features but there arenâ€™t really any standards (the closest solution is JSONAPI). GraphQL comes with some of these specs out-of-box:\nSparse fieldset: while making the request, all the required fields need to be specified, avoiding over-fetching Versioning: route versioning is not a good practice in GraphQL instead, the schema should continually evolve. New capabilities can be inserted on new types and fields, allowing the client to plan and decide when to change to new resolvers. If a field needs to be deprecated, one can use a directive such as @deprecated. Pagination: there are some conventions and, for more complex implementations, there is the Connection model pattern. Of course, there is other stuff that one can compare against REST, but the idea is to show that GraphQL can be an option.\nDeveloper experience Front-end and back-end developers can easily settle on a schema and, in a question of minutes, have stubs built around it. Besides, code generation, IDE auto-completion, easy documentation/schema discovery and good API exploring tools (such as GraphQL Playground and GraphiQL) makes the development experience way nicer when compared to REST.\nGraphQL as your API Gateway High hopes that you are convinced on trying GraphQL ðŸ™Œ Implementing a GraphQL server is not complicated and there are many guides on the web talking about it. The official website has a list with many server frameworks and libraries (comes in many flavours).\nAs mentioned in the first section, an API Gateway has some specific responsibilities. As GraphQL is implemented on top of a normal web server application, one can easily add some of these to it, such as authorisation, metrics and logging. Things such as requests/response transformation, routing and composition are done in the GraphQL resolver level, mapping calls to the right services, using the right communication protocols.\nEven before going full micro-services and using it as a real API Gateway, companies can easily develop everything on top of a GraphQL monolith wait, donâ€™t leave yet and then, with more time and planning, redirect the resolvers to micro-services. This is particularly useful for small companies, which are still testing ideas. During the migration, back-end might change a lot, but front-end will be able to continue requesting the same stuff.\nAs teams develop micro-services, a strategy is required to expose and change the public-facing GraphQL schema. There are some known strategies for it:\nRemote schema stitching The gateway will get the schema from other GraphQL services and then stitch them together as the public-facing schema. This allows more freedom for teams, but it will disperse the API schema through multiple places, making it harder to test and easier to break, with a chance to have merge/stitching conflict.\nAlthough this can be a problem, teams can do releases without even touching the API Gateway, making the deploys isolated instead of requiring constant API Gateways deploys.\nRecently, Apollo Server implemented Federation, which will replace remote schema stitching. Bear in mind it is still Apollo specific.\nAPI Gateway owns schemas The Schema is contained locally on the gateway. This makes development and testing easier, as everything will be in the same place. The caveat is that the service will constantly be modified by multiple teams (resolvers, schemas), requiring constant gateway releases.\nAs this service will be constantly modified by multiple people, rules around code formatting and style should be agreed through all teams to make the code uniform.\nPersonally, I prefer this one as it keeps everything in one place, gives high visibility on what is happening and allows easy discovery of other resolvers.\nCombination of both above It is possible to mix both strategies, which is especially useful if the team wants to use remote schema stitching but have some services using gRPC or HTTP. Another way to tackle those non-GraphQL services is to put a server in front of it, allowing schema stitching and giving more flexibility for the responsible team.\nCaveats of using GraphQL Services can get a bit chatty On the request below, a user wants all posts with its associated author.\nquery { posts(authorId: \"bruno\") { title author { name } } } The issue is, due to the nature of GraphQL, each resolved post will call the author resolver, resulting in N-1 unnecessary calls. Using SQL, it would give us:\nQuery.posts are resolved: SELECT title, author_id FROM posts Query.posts still have un-resolved data about Post.author.name. For each item, GraphQL will call Post.author resolver Post A calls Post.author resolver: SELECT * FROM authors WHERE author_id = 'bruno' Post B calls Post.author resolver again with the same query Post C calls Post.author resolver again with the same query â€¦ The two first selects would have returned the required data, but due to how GraphQL resolvers work â€“ each resolved item with missing data calls the subsequent resolver â€“ all these extra calls are made. This is where the DataLoader pattern shines.\nUsing batching and a cache (per-request only), it will lead your back-end only needing to make the right amount of calls. Probably even saving you from more calls, as the author could have other resolvers to be called. In the previous example it would do something like:\nQuery.posts are resolved: SELECT title, author_id FROM posts. Query.posts still have un-resolved data about Post.author.name. For each item, the service would add a call to DataLoader with the required author_id. After passing through all items, DataLoader would only execute SELECT * FROM authors WHERE author_id = 'bruno' query and return the response. The JavaScript implementation is under 400 LOC, making it easier to explore and understand how it actually works. There are implementations in other languages as well.\nMPJ, from FunFunFunction, released a video series on how to implement GraphQL in NodeJS. Watch the DataLoader video here.\nThrottling is not easy as REST Having everything in one endpoint makes harder to properly implement rate limits because the queries can be quite complex with multiple underlying requests but still one client request. This means an API user canâ€™t be limited through its number of calls to a certain endpoint anymore.\nAn approach to tackle this is by calculating the query complexity and using it as a rate limit score. On GitHub API docs, there are examples of how it works. But, this doesnâ€™t come out-of-box in most server implementations ðŸ˜ž There are some packages such as graphql-validation-complexity and graphql-cost-analysis, where the latter is more advanced, with more options to limit the upcoming queries.\n# Usage example of graphql-cost-analysis type Query { # the cost will depend on the `limit` parameter passed to the field # then the multiplier will be added to the `parent multipliers` array customCostWithResolver(limit: Int): Int @cost(multipliers: [\"limit\"], complexity: 4) # for recursive cost first(limit: Int): First @cost(multipliers: [\"limit\"], useMultipliers: true, complexity: 2) # You can specify several field parameters in the `multipliers` array # then the values of the corresponding parameters will be added together. # here, the cost will be `parent multipliers` * (`first` + `last`) * `complexity severalMultipliers(first: Int, last: Int): Int @cost(multipliers: [\"first\", \"last\"]) } Caching is magic until it isnâ€™t Most clients do caching automatically, but sometimes it doesnâ€™t work as expected, requiring some manual cleaning on the client. Besides, each request might ask for different fields, which makes a bit trickier to cache a resource on the server-side. One might request the whole resource, cache it in memory (eg: Redis), and then allow the API to use it as a reference to select specific fields.\nConclusion Hopefully, this might have clarified some details of using GraphQL as an API gateway. For those who want to go deeper, there are some references below, from where I took notes for this post.\nMany thanks for @southclaws, @SpeedyCoder, @cassiobock and @codepreneur for helping me by reviewing this post.\nReferences API Gateway Ngnix micro-services book chapter about API Gateway Chris Richardson article about API Gateway API Proxy vs API Gateway Pattern: API Gateway / Back-end for Front-End GraphQL GraphQL Documentation GitHub GraphQL Resource Limitations Documentation GraphQL Gateway Architectures Why GraphQL: Advantages, Disadvantages \u0026 Alternatives Why GraphQL is Taking Over APIs Schema stitching â€“ Combining multiple GraphQL APIs into one Apollo Federation FunFunFunction GraphQL Videos Tools Typescript graphql-code-generator DataLoader graphql-validation-complexity graphql-cost-analysis Images Cover Photo by Christian Stahl on Unsplash Other JSONAPI: REST alternative to GraphQL What is over and under-fetching ","wordCount":"1959","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2019-07-01T08:00:00Z","dateModified":"2019-07-01T08:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/graphql-as-a-gateway/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GraphQL feat API Gateway</h1><div class=post-meta><span title='2019-07-01 08:00:00 +0000 UTC'>July 1, 2019</span>&nbsp;Â·&nbsp;10 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/graphql-as-a-gateway/cover_hu_6ad55dbfd0d661c7.jpg 360w,https://brunoluiz.net/blog/graphql-as-a-gateway/cover_hu_7fd116a9b4ce3f08.jpg 480w,https://brunoluiz.net/blog/graphql-as-a-gateway/cover_hu_f167c076fc35bf39.jpg 720w,https://brunoluiz.net/blog/graphql-as-a-gateway/cover_hu_92e9a65c60fdee3a.jpg 1080w,https://brunoluiz.net/blog/graphql-as-a-gateway/cover_hu_5aeb084dec47835b.jpg 1500w,https://brunoluiz.net/blog/graphql-as-a-gateway/cover.jpg 4581w' src=https://brunoluiz.net/blog/graphql-as-a-gateway/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=4581 height=3058 alt="Photo by Christian Stahl on Unsplash"><figcaption>Photo by Christian Stahl on Unsplash</figcaption></figure><div class=post-content><p>GraphQL, REST, gRPC, Thrift&mldr; Have you ever imagined how to stick these together in a micro-services architecture and expose to the world? There are some common ways to do it, such as using Nginx or Kong. But, an alternative way to do this is by using GraphQL in front of all services.</p><h2 id=api-gateway-pattern--a-quick-introduction>API Gateway pattern &ndash; a quick introduction<a hidden class=anchor aria-hidden=true href=#api-gateway-pattern--a-quick-introduction>#</a></h2><p>Consider two services: A and B. How a client would be able to request its data? The easiest way would be to make a request to service A and then another to B, each pointing to a different host (eg: <code>a.service/orders</code> and <code>b.service/users</code>).</p><p>As the number of services grows, it is quite laborious to keep using this strategy. Since there could be too many services and requests to coordinate. To solve this, an API proxy can be used, where the client will request to only one service instead of multiple. This proxy will orchestrate where this request should go, glueing all services in one place.</p><p>While proxies just forward requests, API Gateways encapsulate more of the application&rsquo;s internal architecture. Working as a Facade with some other responsibilities, such as:</p><ul><li>Request/Response Transformation: requests made by a client can be reshaped before being sent to internal services, with the same applying to responses.</li><li>Request routing: as a proxy, it routes requests to specific services, translating to other protocols if required.</li><li>Composition: one request to the gateway can actually be mapped to multiple internal ones.</li><li>Throttling: limit user requests up to a determined threshold.</li><li>Security: protect some endpoints with some sort of authentication (JWT token, basic, API tokens etc).</li><li>Metrics and Logs: as all requests would pass through it, many metrics and logs will be collected through this service.</li></ul><blockquote><p>For more information on the API gateway pattern, take a look at <a href=https://www.nginx.com/blog/building-microservices-using-an-api-gateway/>Nginx micro-services article</a> and on this <a href=https://freecontent.manning.com/the-api-gateway-pattern/>Chris Richardson article</a>.</p></blockquote><h2 id=why-graphql-and-not-rest>Why GraphQL and not REST?<a hidden class=anchor aria-hidden=true href=#why-graphql-and-not-rest>#</a></h2><p>GraphQL was initially developed by Facebook and <a href=https://code.fb.com/core-data/graphql-a-data-query-language/>was open-sourced in 2015</a>. Many companies started using it for internal APIs, but some are already exposing it as its public API (eg: GitHub, Shopify, Yelp and Contentful).</p><h3 id=schema-validation-and-documentation>Schema validation and documentation<a hidden class=anchor aria-hidden=true href=#schema-validation-and-documentation>#</a></h3><p>With GraphQL, in contrast to from REST, a schema is always required, following <a href=https://graphql.org>GraphQL Foundation</a> directives. This allows not only schema validation from day one, but documentation too. Typed languages can benefit from the schema and generate type definitions through it (eg: <a href=https://github.com/dotansimha/graphql-code-generator>typescript graphql-code-generator</a>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Query</span> {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  Fetch posts by user, allowing custom filtering
</span></span></span><span style=display:flex><span><span style=color:#e6db74>  &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>  posts(<span style=color:#66d9ef>input</span>: <span style=color:#a6e22e>PostQueryInput</span>): [<span style=color:#a6e22e>Post</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>input</span> PostQueryInput {
</span></span><span style=display:flex><span>  categoryId: <span style=color:#a6e22e>String</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>Post bla bla bla
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Post</span> {
</span></span><span style=display:flex><span>  title: <span style=color:#a6e22e>String</span>
</span></span><span style=display:flex><span>  categories: [<span style=color:#a6e22e>Category</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Category</span> {
</span></span><span style=display:flex><span>  name: <span style=color:#a6e22e>String</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In theory, the same could be done with REST by using OpenAPI/Swagger, especially for documentation <del>but YAML, yikes</del>. But, the code generation tools are not exactly the best and sometimes the schema validation does not work properly, requiring extra middleware and tweaks around it. As GraphQL is standardised in this sense, it doesn&rsquo;t suffer from these issues.</p><h3 id=one-endpoint-to-rule-them-all>One endpoint to rule them all<a hidden class=anchor aria-hidden=true href=#one-endpoint-to-rule-them-all>#</a></h3><p>GraphQL only exposes one endpoint. Instead of having N client requests, only one is needed. The server orchestrates everything required to fulfil the whole request, such as: calling multiple micro-services (with any protocol), mapping outputs to the expected schema and logging requests/responses. Besides, this solves <a href=https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching/44568365>under-fetching issues</a>.</p><h3 id=out-of-box-standards>Out-of-box standards<a hidden class=anchor aria-hidden=true href=#out-of-box-standards>#</a></h3><p>REST has been around for a long time, and during this period developers started to have specific necessities, such as sparse fieldsets, versioning, pagination. There are many ways to implement these features but there aren&rsquo;t really any standards (the closest solution is <a href=https://jsonapi.org/>JSONAPI</a>). GraphQL comes with some of these specs out-of-box:</p><ul><li><a href=https://graphql.org/learn/queries/#fields>Sparse fieldset</a>: while making the request, all the required fields need to be specified, avoiding over-fetching</li><li><a href=https://graphql.org/learn/best-practices/#versioning>Versioning</a>: route versioning is not a good practice in GraphQL instead, the schema should continually evolve. New capabilities can be inserted on new types and fields, allowing the client to plan and decide when to change to new resolvers. If a field needs to be deprecated, one can use a directive such as <a href=https://www.apollographql.com/docs/graphql-tools/schema-directives><code>@deprecated</code></a>.</li><li><a href=https://graphql.org/learn/pagination/>Pagination</a>: there are some conventions and, for more complex implementations, there is the Connection model pattern.</li></ul><p>Of course, there is other stuff that one can compare against REST, but the idea is to show that GraphQL can be an option.</p><h3 id=developer-experience>Developer experience<a hidden class=anchor aria-hidden=true href=#developer-experience>#</a></h3><p>Front-end and back-end developers can easily settle on a schema and, in a question of minutes, have stubs built around it. Besides, code generation, IDE auto-completion, easy documentation/schema discovery and good API exploring tools (such as GraphQL Playground and GraphiQL) makes the development experience way nicer when compared to REST.</p><h2 id=graphql-as-your-api-gateway>GraphQL as your API Gateway<a hidden class=anchor aria-hidden=true href=#graphql-as-your-api-gateway>#</a></h2><p>High hopes that you are convinced on trying GraphQL ðŸ™Œ Implementing a GraphQL server is not complicated and there are many guides on the web talking about it. The official website <a href=https://graphql.org/code>has a list with many server frameworks and libraries</a> (comes in many flavours).</p><p>As mentioned in the first section, an API Gateway has some specific responsibilities. As GraphQL is implemented on top of a normal web server application, one can easily add some of these to it, such as authorisation, metrics and logging. Things such as requests/response transformation, routing and composition are done in the GraphQL resolver level, mapping calls to the right services, using the right communication protocols.</p><blockquote><p>Even before going full micro-services and using it as a real API Gateway, companies can easily develop everything on top of a GraphQL monolith <del>wait, don&rsquo;t leave yet</del> and then, with more time and planning, redirect the resolvers to micro-services. This is particularly useful for small companies, which are still testing ideas. During the migration, back-end might change a lot, but front-end will be able to continue requesting the same stuff.</p></blockquote><p>As teams develop micro-services, a strategy is required to expose and change the public-facing GraphQL schema. There are some known strategies for it:</p><h3 id=remote-schema-stitching>Remote schema stitching<a hidden class=anchor aria-hidden=true href=#remote-schema-stitching>#</a></h3><p>The gateway will get the schema from other GraphQL services and then stitch them together as the public-facing schema. This allows more freedom for teams, but it will disperse the API schema through multiple places, making it harder to test and easier to break, with a chance to have merge/stitching conflict.</p><p>Although this can be a problem, teams can do releases without even touching the API Gateway, making the deploys isolated instead of requiring constant API Gateways deploys.</p><blockquote><p>Recently, Apollo Server implemented <a href=https://www.apollographql.com/docs/apollo-server/federation/introduction/>Federation</a>, which will replace remote schema stitching. Bear in mind it is still Apollo specific.</p></blockquote><h3 id=api-gateway-owns-schemas>API Gateway owns schemas<a hidden class=anchor aria-hidden=true href=#api-gateway-owns-schemas>#</a></h3><p>The Schema is contained locally on the gateway. This makes development and testing easier, as everything will be in the same place. The caveat is that the service will constantly be modified by multiple teams (resolvers, schemas), requiring constant gateway releases.</p><p>As this service will be constantly modified by multiple people, rules around code formatting and style should be agreed through all teams to make the code uniform.</p><blockquote><p>Personally, I prefer this one as it keeps everything in one place, gives high visibility on what is happening and allows easy discovery of other resolvers.</p></blockquote><h3 id=combination-of-both-above>Combination of both above<a hidden class=anchor aria-hidden=true href=#combination-of-both-above>#</a></h3><p>It is possible to mix both strategies, which is especially useful if the team wants to use remote schema stitching but have some services using gRPC or HTTP. Another way to tackle those non-GraphQL services is to put a server in front of it, allowing schema stitching and giving more flexibility for the responsible team.</p><h2 id=caveats-of-using-graphql>Caveats of using GraphQL<a hidden class=anchor aria-hidden=true href=#caveats-of-using-graphql>#</a></h2><h3 id=services-can-get-a-bit-chatty>Services can get a bit chatty<a hidden class=anchor aria-hidden=true href=#services-can-get-a-bit-chatty>#</a></h3><p>On the request below, a user wants all posts with its associated author.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#66d9ef>query</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>posts</span>(authorId: <span style=color:#e6db74>&#34;bruno&#34;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>title</span>
</span></span><span style=display:flex><span>    author {
</span></span><span style=display:flex><span>      name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The issue is, due to the nature of GraphQL, each resolved <code>post</code> will call the <code>author</code> resolver, resulting in <code>N-1</code> unnecessary calls. Using SQL, it would give us:</p><ul><li><code>Query.posts</code> are resolved: <code>SELECT title, author_id FROM posts</code></li><li><code>Query.posts</code> still have un-resolved data about <code>Post.author.name</code>. For each item, GraphQL will call <code>Post.author</code> resolver</li><li>Post A calls <code>Post.author</code> resolver: <code>SELECT * FROM authors WHERE author_id = 'bruno'</code></li><li>Post B calls <code>Post.author</code> resolver again with the same query</li><li>Post C calls <code>Post.author</code> resolver again with the same query</li><li>&mldr;</li></ul><p>The two first selects would have returned the required data, but due to how GraphQL resolvers work &ndash; each resolved item with missing data calls the subsequent resolver &ndash; all these extra calls are made. This is where the <a href=https://github.com/graphql/dataloader>DataLoader</a> pattern shines.</p><p>Using batching and a cache (per-request only), it will lead your back-end only needing to make the right amount of calls. Probably even saving you from more calls, as the <code>author</code> could have other resolvers to be called. In the previous example it would do something like:</p><ul><li><code>Query.posts</code> are resolved: <code>SELECT title, author_id FROM posts</code>.</li><li><code>Query.posts</code> still have un-resolved data about <code>Post.author.name</code>. For each item, the service would add a call to DataLoader with the required <code>author_id</code>.</li><li>After passing through all items, DataLoader would only execute <code>SELECT * FROM authors WHERE author_id = 'bruno'</code> query and return the response.</li></ul><p>The JavaScript implementation is under 400 LOC, making it easier to explore and understand how it actually works. <a href=https://github.com/graphql/dataloader/blob/master/README.md#other-implementations>There are implementations in other languages as well</a>.</p><blockquote><p>MPJ, from FunFunFunction, released a <a href="https://www.youtube.com/watch?v=lAJWHHUz8_8&amp;list=PL0zVEGEvSaeEjIDdbK1KfR7V9XBCVAr0P">video series</a> on how to implement GraphQL in NodeJS. <a href="https://www.youtube.com/watch?v=--AguZ20lLA&amp;list=PL0zVEGEvSaeEjIDdbK1KfR7V9XBCVAr0P&amp;index=3">Watch the DataLoader video here</a>.</p></blockquote><h3 id=throttling-is-not-easy-as-rest>Throttling is not easy as REST<a hidden class=anchor aria-hidden=true href=#throttling-is-not-easy-as-rest>#</a></h3><p>Having everything in one endpoint makes harder to properly implement rate limits because the queries can be quite complex with multiple underlying requests but still one client request. This means an API user can&rsquo;t be limited through its number of calls to a certain endpoint anymore.</p><p>An approach to tackle this is by calculating the query complexity and using it as a rate limit score. <a href=https://developer.github.com/v4/guides/resource-limitations/>On GitHub API docs</a>, there are examples of how it works. But, this doesn&rsquo;t come out-of-box in most server implementations ðŸ˜ž There are some packages such as <a href=https://github.com/4Catalyzer/graphql-validation-complexity><code>graphql-validation-complexity</code></a> and <a href=https://github.com/pa-bru/graphql-cost-analysis><code>graphql-cost-analysis</code></a>, where the latter is more advanced, with more options to limit the upcoming queries.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-graphql data-lang=graphql><span style=display:flex><span><span style=color:#75715e># Usage example of graphql-cost-analysis</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Query</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e># the cost will depend on the `limit` parameter passed to the field</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># then the multiplier will be added to the `parent multipliers` array</span>
</span></span><span style=display:flex><span>  customCostWithResolver(limit: <span style=color:#a6e22e>Int</span>): <span style=color:#a6e22e>Int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cost</span>(multipliers: [<span style=color:#e6db74>&#34;limit&#34;</span>], <span style=color:#a6e22e>complexity</span>: <span style=color:#a6e22e>4</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># for recursive cost</span>
</span></span><span style=display:flex><span>  first(limit: <span style=color:#a6e22e>Int</span>): <span style=color:#a6e22e>First</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cost</span>(multipliers: [<span style=color:#e6db74>&#34;limit&#34;</span>], <span style=color:#a6e22e>useMultipliers</span>: <span style=color:#a6e22e>true</span>, complexity: <span style=color:#a6e22e>2</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># You can specify several field parameters in the `multipliers` array</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># then the values of the corresponding parameters will be added together.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># here, the cost will be `parent multipliers` * (`first` + `last`) * `complexity</span>
</span></span><span style=display:flex><span>  severalMultipliers(first: <span style=color:#a6e22e>Int</span>, last: <span style=color:#a6e22e>Int</span>): <span style=color:#a6e22e>Int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@cost</span>(multipliers: [<span style=color:#e6db74>&#34;first&#34;</span>, <span style=color:#e6db74>&#34;last&#34;</span>])
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=caching-is-magic-until-it-isnt>Caching is magic until it isn&rsquo;t<a hidden class=anchor aria-hidden=true href=#caching-is-magic-until-it-isnt>#</a></h3><p>Most clients do caching automatically, but sometimes it doesn&rsquo;t work as expected, requiring some manual cleaning on the client. Besides, each request might ask for different fields, which makes a bit trickier to cache a resource on the server-side. One might request the whole resource, cache it in memory (eg: Redis), and then allow the API to use it as a reference to select specific fields.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>Hopefully, this might have clarified some details of using GraphQL as an API gateway. For those who want to go deeper, there are some references below, from where I took notes for this post.</p><p>Many thanks for <a href=https://www.southcla.ws/>@southclaws</a>, <a href=http://michalbock.com/>@SpeedyCoder</a>, <a href=https://github.com/cassiobock>@cassiobock</a> and <a href=https://www.codepreneur.io/>@codepreneur</a> for helping me by reviewing this post.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><h4 id=api-gateway>API Gateway<a hidden class=anchor aria-hidden=true href=#api-gateway>#</a></h4><ul><li><a href=https://www.nginx.com/blog/building-microservices-using-an-api-gateway/>Ngnix micro-services book chapter about API Gateway</a></li><li><a href=https://freecontent.manning.com/the-api-gateway-pattern/>Chris Richardson article about API Gateway</a></li><li><a href=https://stoplight.io/blog/api-proxy-vs-api-gateway-c008c942a02d/>API Proxy vs API Gateway</a></li><li><a href=https://microservices.io/patterns/apigateway.html>Pattern: API Gateway / Back-end for Front-End</a></li></ul><h4 id=graphql>GraphQL<a hidden class=anchor aria-hidden=true href=#graphql>#</a></h4><ul><li><a href=https://graphql.org/learn/>GraphQL Documentation</a></li><li><a href=https://developer.github.com/v4/guides/resource-limitations/>GitHub GraphQL Resource Limitations Documentation</a></li><li><a href=https://tomasalabes.me/blog/graphql/node/microservices/2018/08/11/graphql-architectures.html>GraphQL Gateway Architectures</a></li><li><a href=https://www.robinwieruch.de/why-graphql-advantages-disadvantages-alternatives/>Why GraphQL: Advantages, Disadvantages & Alternatives</a></li><li><a href=https://webapplog.com/graphql/>Why GraphQL is Taking Over APIs</a></li><li><a href=https://www.apollographql.com/docs/graphql-tools/schema-stitching>Schema stitching &ndash; Combining multiple GraphQL APIs into one</a></li><li><a href=https://blog.apollographql.com/apollo-federation-f260cf525d21>Apollo Federation</a></li><li><a href="https://www.youtube.com/watch?v=lAJWHHUz8_8&amp;list=PL0zVEGEvSaeEjIDdbK1KfR7V9XBCVAr0P">FunFunFunction GraphQL Videos</a></li></ul><h4 id=tools>Tools<a hidden class=anchor aria-hidden=true href=#tools>#</a></h4><ul><li><a href=https://github.com/dotansimha/graphql-code-generator>Typescript <code>graphql-code-generator</code></a></li><li><a href=https://github.com/graphql/dataloader>DataLoader</a></li><li><a href=https://github.com/4Catalyzer/graphql-validation-complexity><code>graphql-validation-complexity</code></a></li><li><a href=https://github.com/pa-bru/graphql-cost-analysis><code>graphql-cost-analysis</code></a></li></ul><h4 id=images>Images<a hidden class=anchor aria-hidden=true href=#images>#</a></h4><ul><li><a href=https://unsplash.com/photos/8S96OpxSlvg>Cover Photo by Christian Stahl on Unsplash</a></li></ul><h4 id=other>Other<a hidden class=anchor aria-hidden=true href=#other>#</a></h4><ul><li><a href=https://jsonapi.org/>JSONAPI: REST alternative to GraphQL</a></li><li><a href=https://stackoverflow.com/questions/44564905/what-is-over-fetching-or-under-fetching/44568365>What is over and under-fetching</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/2019/nov/grpc-a-powerful-way-to-improve-golang-apis/><span class=title>Â« Prev</span><br><span>GRPC: A powerful way to improve your Golang APIs</span>
</a><a class=next href=https://brunoluiz.net/blog/2019/mar/kubernetes-devops-productivity-hacks/><span class=title>Next Â»</span><br><span>Kubernetes devops productivity hacks</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> Â·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>