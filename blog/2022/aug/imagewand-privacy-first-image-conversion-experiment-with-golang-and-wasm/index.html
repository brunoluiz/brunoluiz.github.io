<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>ImageWand: privacy-first image conversion experiment with Golang & WASM | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="After my experiment with GIFSane, one thing was clear: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript. It is finally time to try to create something from scratch, using Golang WASM toolchain"><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="ImageWand: privacy-first image conversion experiment with Golang & WASM"><meta property="og:description" content="After my experiment with GIFSane, one thing was clear: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript. It is finally time to try to create something from scratch, using Golang WASM toolchain"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-08-07T12:00:00+00:00"><meta property="article:modified_time" content="2022-08-07T12:00:00+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="ImageWand: privacy-first image conversion experiment with Golang & WASM"><meta name=twitter:description content="After my experiment with GIFSane, one thing was clear: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript. It is finally time to try to create something from scratch, using Golang WASM toolchain"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"ImageWand: privacy-first image conversion experiment with Golang \u0026 WASM","item":"https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"ImageWand: privacy-first image conversion experiment with Golang \u0026 WASM","name":"ImageWand: privacy-first image conversion experiment with Golang \u0026 WASM","description":"After my experiment with GIFSane, one thing was clear: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript. It is finally time to try to create something from scratch, using Golang WASM toolchain","keywords":[],"articleBody":" üß≠ If you are looking for ImageWand repository, head to brunoluiz/imagewand\nAt the beginning of the year, I was curious about WebAssembly (WASM). The result was GIFSane, but that was not enough: FFMpeg.wasm was already pre-compiled, and I only had to sort out how to use it within an extension. One thing was clear though: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript.\nI‚Äôve moved houses quite recently. It meant manipulating tons of documents, converting to different formats, resizing etc. Mac‚Äôs Preview app can handle it, but many might rely on browsers due to the first search results for ‚ÄúConvert image format1 format2‚Äù. Seriously, look at these Google results.\nWhen someone is converting a puppy image from JPG to PDF this might be ok. But after hearing that my family used these sites to convert documents like Passports, I got scared. Most people don‚Äôt realise that these files go to a server, and they can be stored for whatever reason and for an indefinite time. ‚ÄúIdentity theft‚Äù sends its regards üòÖ\nWhat if there was some website to convert images locally, without requiring a server? What if the technology for that already exists? That is when I started developing ImageWand (source).\nConverting your images locally and privately: ImageWand ImageWand converts images locally using WASM and Golang. In the future, it could potentially resize and compress images, but I tried to keep it simple by only using standard libraries encoders and decoders (no PDF for now).\nIt seems that Rust would have been a more solid choice for WASM, but I would have to learn it to develop this project. Rust is famous for its steep learning curve and, to keep things simple and focused, I went with Golang.\nLess is more, although I guess the application could benefit from more features üòÖ The building experience Golang offers some standard libraries for image manipulation (image package). Implementing something to convert A to B wasn‚Äôt the hard part. The conversion logic was extracted and re-used in both CLI and WASM implementations, which is impressive in terms of portability.\nCovering the basics: interfacing with user input In a CLI, the application can receive user input through flags or arguments. In WASM, things are a bit peculiar as inputs have to come from JavaScript into Golang.\nYou can instantiate and load the WASM binary for every call, similar to a CLI call, but it would be an expensive operation. The best way is to run it in the background (observe the use of a channel to keep it running) while developers call it through a JavaScript interface.\nIn Golang, this is done by exposing global JavaScript objects/functions within main(). It is not great as it might conflict with other variables and it pollutes the global scope. Other WASM implementations (Rust or TinyGo+WASI) expose methods by exporting them in the WASM instance, which is cleaner than relying on global variables.\nfunc main() { fmt.Println(\"Starting ImageWand ü™Ñ\") js.Global().Set(\"wand\", map[string]interface{}{ \"convertFromURL\": convertFromURL(), \"convertFromBlob\": convertFromBlob(), }) \u003c-make(chan bool) } Interacting with ‚ÄúJavaScript-land‚Äù To declare and interact with JavaScript in Golang runtime, developers rely on syscall/js. This package allows the application to create functions, read values from JS objects (DOM and non-DOM) and interface byte arrays with JS values (specifically: UInt8Array). The only caveat is the following, been present since its release on Golang 1.11.\nThis package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.\nAlthough it allows all sorts of interactions with JavaScript, in my limited experience with it, I would recommend developers to only use it to interface user inputs between Golang and the JavaScript runtime.\nIf you want to manipulate DOM or create elaborate objects through Golang, you might be in a world of pain. Not only there are no typing guarantees, but the tooling for those is just not there. ImageWand only uses it to gather user input to call imagewand conversion functions, essentially a glue between the UI and Golang.\nI‚Äôve created an internal package (jasm) with a few helper functions to interface with JavaScript values. It made wasm/main.go way cleaner, but certainly the most important of all is the Await method.\nGolang and JavaScript promises JavaScript applications are single-threaded and leverage an event-loop strategy. Certain tasks might cause it to block, such as disk or network operations. JavaScript can schedule these operations by spinning processes off the event-loop, without blocking the main thread. A common way of doingit is through Promises.\nGolang HTTP calls are using JavaScript‚Äôs fetch under the hood, for example. This results in a blocking operation (network call), which needs to be handled properly. Using net/http functions incorrectly will result in a runtime deadlock error. It is a common mistake, been even pointed out on the syscall/js.FuncOf documentation:\nInvoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.\nAs a consequence, if one wrapped function blocks, JavaScript‚Äôs event loop is blocked until that function returns. Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.\nStarting goroutine solves event loop blocking. Image processing would definetely be a blocking operation and definitely be spun up in a goroutine. But, JavaScript doesn‚Äôt ‚Äúunderstand‚Äù them, and the application needs to signal JavaScript runtime to wait for its results. The easiest way is to create a Promise through syscall/js and call resolve() through the goroutine.\nAs it is a bit of a long piece of code, abstraction is vital. In ImageWand, this is dealt with through the jasm.Await function.\nfunc Await(cb func() (js.Value, error)) js.Value { handler := js.FuncOf(func(this js.Value, args []js.Value) interface{} { resolve := args[0] reject := args[1] // This would be the function I want to deal with go func() { res, err := cb() if err != nil { reject.Invoke(Error(err)) return } resolve.Invoke(res) }() return nil }) return promiseJS.New(handler) } This way, any blocking operation can be created as a promise by wrapping it through this. There is a pull request open at golang/go that implements a better version of this snippet, perhaps landing in a future version of Go.\nOptimisations Once the proof of concept was up and running, there was a problem: binary size. At this point, building without any optimisation generated a 3.2Mb binary. Not ideal for mobile usage.\nGOOS=js GOARCH=wasm go build -o ./app/wasm/main-go.wasm ./cmd/wasm The first optimisation one can do is to disable the injection of debugging information on build time through ldflags. For ImageWand, it reduced the binary to 3.1Mb (2%). Although quite low effort, it doesn‚Äôt help much.\nGOOS=js GOARCH=wasm go build -o ./app/wasm/main-go-optimal.wasm -ldflags=\"-s -w\" ./cmd/wasm Tools like twiggy can help analyse the binary size as well. There wasn‚Äôt much to tweak in this case, but I recommend giving it a try. The one that everyone recommends though, regardless of language, is wasm-opt from the binaryen toolchain.\nIt allows many optimisations, but it requires a bit of tweaking per-project basis. After playing around with it, the previous optimised binary with -Oz produced the best results: a 2.9Mb binary, a 7% reduction compared to the original binary.\nwasm-opt -Oz -o ./app/wasm/main-go-optimal-binaryen.wasm ./app/wasm/main-go-optimal.wasm With Golang compiler, this is as far as I could go with optimisations. Even considering Gzip, it didn‚Äôt look great. It is not rare to find websites reaching 1Mb nowadays but, for such a simple project, 2.9Mb is unacceptable.\nBinary size per optimisation: no excessive gains, but still something TinyGo: a better compiler for WASM? I heard about TinyGo sometime ago. With the slogan ‚ÄúA Go Compiler For Small Places‚Äù and a focus on embedded systems, I never got on the hype train. It is a subset of the Golang language, which means there are some limitations and not all packages will work on it, even the ones in the standard library. This means it is not exactly a drop-in for all scenarios.\nBut, besides embedded systems, it seems to be a quite popular WASM compiler. The binaries produced, being a subset and focused on ‚Äúsmall places‚Äù, are quite small. Taking into consideration the supported packages and limitations, it seemed a good candidate for ImageWand.\nAlmost a drop-in replacement The first thing I tried was to compile the program using TinyGo, without any changes. It worked incredibly well, and the binary size dropped from ~3.2Mb to ~1.5Mb. Quite an improvement, especially when the WASM target is a web browser.\nThis was until I checked the console. Using .String() to get values from syscall/js.Value has not been implemented. Seemingly, ImageWand hit a TinyGo limitation and a hack around would be required.\nThere are some hacks for it, but they all have some memory leak issues. As the surface between the program functionality and syscall/js is quite limited, changing those into int seemed a better solution (without any caveat).\nBesides this, anyone attempting to move from Golang to TinyGo has to replacewasm_exec.js. According to the documentation, it is based on the Go‚Äôs one, but with a couple of changes that make it incompatible. Nothing major and super easy to tackle.\nOnce tweaked, ImageWand was successfully compiled using TinyGo, without any error messages in runtime and a binary twice the original size (1.5Mb). Smells like progress!\nTinyGo after optimisations Similar to Golang, the TinyGo compiler allows tweaks according to project requirements. Considering this will be distributed on the web, optimisations related to size are important. Some might prefer performance tweaks, which are available as well.\ntinygo build -o app/wasm/main-tinygo-optimal.wasm -target wasm -no-debug -gc leaking ./cmd/wasm wasm-opt -Oz -o ./app/wasm/main-tinygo-optimal-binaryen.wasm ./app/wasm/main-tinygo-optimal.wasm As in Golang though, wasm-opt did not result in a massive gain, but it is still something.\nTinyGo binary size per optimisation: drastic improvements when applying optimisations Full binary size comparison from Golang to Tinygo + optimisations If your implementation is compatible with TinyGo and you don‚Äôt fall into an edge case, go for it! It provides plenty of features, and it seems a good choice in terms of binary size, especially considering web distribution.\nWASI: interesting but not mature enough on TinyGo At this point, ImageWand was working and it was not a large binary: I could call it a day. But, there was still one thing that I wanted to try out: WASI.\nWASI stands for WebAssembly System Interface. It‚Äôs an API designed by the Wasmtime project that provides access to several operating-system-like features, including files and filesystems, Berkeley sockets, clocks, and random numbers, that we‚Äôll be proposing for standardisation.\nIt‚Äôs designed to be independent of browsers, so it doesn‚Äôt depend on Web APIs or JS, and isn‚Äôt limited by the need to be compatible with JS. And it has integrated capability-based security, so it extends WebAssembly‚Äôs characteristic sandboxing to include I/O.\n‚ÑπÔ∏è There is an interesting article from MDN about the subject ‚Äì It is something I definitely want to dive deeper into in the future\nImageWand was relying on syscall/js to interface with user input, which depends on JavaScript APIs, and it wouldn‚Äôt run in any other runtime besides the browser. Binaries compiled into the WASI standard though can be run anywhere that implements its specification: browser, terminal or within other backends (serverless function with NodeJS running Golang WASI bins). Yes, ‚ÄúBuild once, run everywhere‚Äù Java vibes.\nTinyGo supports WASI. This means syscall/js is not required if you don‚Äôt want to manipulate the DOM, which would have made ImageWand code simpler, becoming just an exported Golang function‚Ä¶ But, there are a couple of limitations when implementing WASI programs with TinyGo:\nFunction arguments and outputs can only be numbers or pointers, which are essentially numbers with a memory address. There is no proper support for multi-return, so no easy (someType, error) without some hacks. Lacking documentation and helper methods to operate on top of shared WASM memory (I‚Äôve opened a ticket around documentation). ImageWand was passing a slice of byte with the image content, which was the simplest way to get this working (don‚Äôt io.Reader me: it is not as simple). To pass the image input and receive the output in []byte, you need to use JavaScript and WASM shared memory space, pointers and all sort of low-level magic.\nChecking Github, it seems many people came across the issue of passing non-numeric values or returning multiple values, and every developer has a different solution to it [1] [2].Eventually, I came up with my way of dealing with this, but it is quite ugly and probably not efficient at all. Most likely I should have used WebAssembly.memory.buffer, but I couldn‚Äôt find an easy way of doing so. Besides, WASI was an extra in this whole experiment and, at this point, I had invested a long time cracking my head to have at least something minimal working.\n// JavaScript code new Uint8Array(buf).forEach((b) =\u003e imagewand.appendToBuffer(b)); await imagewand.convertFromBlob(formatToNumber(format)); const outputSize = imagewand.getOutputSize(); const arrayBuffer = new Uint8Array(outputSize); for (let i = 0; i \u003c outputSize; i++) { arrayBuffer[i] = imagewand.getOutputAtPos(i); } // Golang code type image []byte var input image; var output image; //export appendToBuffer func appendToBuffer(i byte) { input = append(input, i) } //export getOutputSize func getOutputSize() int { return len(output) } //export getOutputAtPos func getOutputAtPos(i int) byte { return output[i] } // Other stuff //export convertFromBlob func convertFromBlob(format int) { img, err := imagewand.New(bytes.NewBuffer(input)) if err != nil { panic(err) } f, ok := fileFormatFromInt[format] if !ok { panic(\"format not supported\") } b := bytes.NewBuffer([]byte{}) if err := img.Convert(b, f); err != nil { panic(err) } output = b.Bytes() input = []byte{} } These limitations and lack of documentation around WASI, workarounds and common examples for TinyGo make it quite hard to abandon syscall/js for browser apps or use it for non-JS WASM applications. Although I managed to make it work, I wouldn‚Äôt recommend someone to drop syscall/js in favour of WASI TinyGo for browser applications at the moment, only if the person wants to deep dive and study its details. If you decide to do so, please help the community by adding examples, tutorials and documentation to the official project page.\nConclusions on using Golang with WASM Being able to re-use and compile Golang code into WASM is exciting. Besides, for those used to Golang as their daily driver, it might be a natural choice when considering complex applications.\nIn general, I always recommend Golang due its tooling. But, for WASM, my experience was quite bumpy:\nThe final binary size using Golang toolchain (around 3.2Mb) might be OK for the backend but not for frontend apps. This adds up when considering network outbound costs or slow mobile connections. TinyGo is an amazing alternative, but you might fall into edge-cases or unsupported features. This is quite an annoyance but, if you manage to get your way around it, it is probably the perfect choice for your Golang WASM project. CI pipelines will get more complex as Golang/TinyGo tooling needs to be handled, and extra build steps are required. Not that JavaScript toolchain is not complex by itself already. The use of syscall/js is quite cumbersome and unsafe, but mostly because of the JavaScript nature. Dealing with DOM elements is possible, but changing UI elements is quite a painful and complex task. Try to limit its use only as glue. Golang WASM is an independent and experimental port. There are discussions on how to deal with such ports, but it is something to bear in mind. Besides, as it is still not a stable API, it might change at any point (although it never changed since its release). WASI support is Golang does not exist at the moment, and TinyGo is not the most ergonomic in terms of WASI development, with a lack of documentation and examples. This can be mostly due to the WASI specification, as it is still in progress, but things like wasm-bindgen for Rust prove that it could be somehow possible. Would I choose Golang for a WASM project? If I had to develop something quickly or the people involved are used to Golang, definitely yes (TinyGo, to be fair). But I feel it is not the best choice in terms of features, documentation, toolchain and support. C/C++ and Rust seem to lead the way.\nI never programmed with Rust before, but considering its support to WASM and some other interesting use cases I have in mind, it is perhaps a sign that I should finally try to learn it.\nüîó ImageWand project page üíæ ImageWand source code üí¨ Reach me on Twitter @ brunoluiz References Go, WebAssembly, HTTP requests and Promises MDN: Transferable objects Running Go in the Browser with WASM and Web Workers Using WebAssembly with Web Workers Shrink Your TinyGo WebAssembly Modules by 60% Are We Wasm Yet ? - Part 1 Are We Wasm Yet ? - Part 2 Standardizing WASI: A system interface to run WebAssembly outside the web WASI WebAssembly Linear Memory example ","wordCount":"2858","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2022-08-07T12:00:00Z","dateModified":"2022-08-07T12:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">ImageWand: privacy-first image conversion experiment with Golang & WASM</h1><div class=post-meta><span title='2022-08-07 12:00:00 +0000 UTC'>August 7, 2022</span>&nbsp;¬∑&nbsp;14 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover_hu_92b4be7de79b12f0.jpg 360w,https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover_hu_9e605a61d71b6e8.jpg 480w,https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover_hu_9fa03f7420e5c80.jpg 720w,https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover_hu_f9ffbd02f53979ca.jpg 1080w,https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover_hu_6a1cbe7fa533dab4.jpg 1500w,https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover.jpg 2074w' src=https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=2074 height=1166 alt="Photo by Mark Tegethoff on Unsplash"><figcaption><a href=https://unsplash.com/photos/NbgQfUvKFE0>Photo by Mark Tegethoff on Unsplash</a></figcaption></figure><div class=post-content><blockquote><p>üß≠ If you are looking for ImageWand repository, head to <a href=https://github.com/brunoluiz/imagewand>brunoluiz/imagewand</a></p></blockquote><p>At the beginning of the year, I was curious about WebAssembly (WASM). <a href=https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/>The result was GIFSane</a>, but that was not enough: <a href=https://github.com/ffmpegwasm/ffmpeg.wasm>FFMpeg.wasm</a> was already pre-compiled, and I only had to sort out how to use it within an extension. One thing was clear though: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript.</p><p>I&rsquo;ve moved houses quite recently. It meant manipulating tons of documents, converting to different formats, resizing etc. Mac&rsquo;s Preview app can handle it, but many might rely on browsers due to the first search results for &ldquo;Convert image format1 format2&rdquo;. Seriously, look at these Google results.</p><p><img alt="Google results for &lsquo;convert image&rsquo;" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/01-google-search.png></p><p>When someone is converting a puppy image from JPG to PDF this might be ok. But after hearing that my family used these sites to convert documents like Passports, I got scared. Most people don&rsquo;t realise that these files go to a server, and they can be stored for whatever reason and for an indefinite time. &ldquo;Identity theft&rdquo; sends its regards üòÖ</p><p>What if there was some website to convert images locally, without requiring a server? What if the technology for that already exists? That is when I started developing <a href=https://imagewand.concordalabs.com/>ImageWand</a> (<a href=https://github.com/brunoluiz/imagewand>source</a>).</p><h2 id=converting-your-images-locally-and-privately-imagewand>Converting your images locally and privately: ImageWand<a hidden class=anchor aria-hidden=true href=#converting-your-images-locally-and-privately-imagewand>#</a></h2><p>ImageWand converts images locally using WASM and Golang. In the future, it could potentially resize and compress images, but I tried to keep it simple by only using standard libraries encoders and decoders (no PDF for now).</p><p>It seems that Rust would have been a more solid choice for WASM, but I would have to learn it to develop this project. Rust is famous for its <a href=https://users.rust-lang.org/t/making-rust-easy-to-learn-and-use/65866/3>steep learning curve</a> and, to keep things simple and focused, I went with Golang.</p><p><img alt="ImageWand main page" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/02-imagewand.png></p><center><small>Less is more, although I guess the application could benefit from more features üòÖ</small></center><h2 id=the-building-experience>The building experience<a hidden class=anchor aria-hidden=true href=#the-building-experience>#</a></h2><p>Golang offers some standard libraries for image manipulation (<a href=https://pkg.go.dev/image><code>image</code> package</a>). Implementing something to convert A to B wasn&rsquo;t the hard part. <a href=https://github.com/brunoluiz/imagewand/blob/v1.0.0/imagewand.go>The conversion logic was extracted and re-used</a> in both CLI and WASM implementations, which is impressive in terms of portability.</p><h3 id=covering-the-basics-interfacing-with-user-input>Covering the basics: interfacing with user input<a hidden class=anchor aria-hidden=true href=#covering-the-basics-interfacing-with-user-input>#</a></h3><p>In a CLI, the application can receive user input through flags or arguments. In WASM, things are a bit peculiar as inputs have to come from JavaScript into Golang.</p><p>You can instantiate and load the WASM binary for every call, similar to a CLI call, but it would be an expensive operation. The best way is to run it in the background (<a href=https://github.com/brunoluiz/imagewand/blob/v1.0.0/cmd/wasm/main.go#L54>observe the use of a channel to keep it running</a>) while developers call it through a JavaScript interface.</p><p>In Golang, this is done by <a href=https://github.com/brunoluiz/imagewand/blob/v1.0.0/cmd/wasm/main.go#L51-L53>exposing global JavaScript objects/functions within <code>main()</code></a>. It is not great as it might conflict with other variables and it pollutes the global scope. Other WASM implementations (Rust or TinyGo+WASI) <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance/exports>expose methods by exporting them</a> in the WASM instance, which is cleaner than relying on global variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Starting ImageWand ü™Ñ&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Global</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;wand&#34;</span>, <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;convertFromURL&#34;</span>: <span style=color:#a6e22e>convertFromURL</span>(),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;convertFromBlob&#34;</span>: <span style=color:#a6e22e>convertFromBlob</span>(),
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  <span style=color:#f92672>&lt;-</span>make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>bool</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=interacting-with-javascript-land>Interacting with &ldquo;JavaScript-land&rdquo;<a hidden class=anchor aria-hidden=true href=#interacting-with-javascript-land>#</a></h3><p>To declare and interact with JavaScript in Golang runtime, developers rely on <a href=https://pkg.go.dev/syscall/js><code>syscall/js</code></a>. This package allows the application to create functions, read values from JS objects (DOM and non-DOM) and interface byte arrays with JS values (specifically: <code>UInt8Array</code>). The only caveat is the following, been present since its release on Golang 1.11.</p><blockquote><p><em>This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.</em></p></blockquote><p>Although it allows all sorts of interactions with JavaScript, in my limited experience with it, I would recommend developers to only use it to interface user inputs between Golang and the JavaScript runtime.</p><p>If you want to manipulate DOM or create elaborate objects through Golang, you might be in a world of pain. Not only there are no typing guarantees, but the tooling for those is just not there. ImageWand only uses it to gather user input to call <code>imagewand</code> conversion functions, essentially a glue between the UI and Golang.</p><p>I&rsquo;ve <a href=https://github.com/brunoluiz/imagewand/blob/main/jasm/wasm.go>created an internal package (jasm)</a> with a few helper functions to interface with JavaScript values. <a href=https://github.com/brunoluiz/imagewand/blob/main/cmd/wasm/main.go#L20-L48>It made <code>wasm/main.go</code> way cleaner</a>, but certainly the most important of all is the <code>Await</code> method.</p><h3 id=golang-and-javascript-promises>Golang and JavaScript promises<a hidden class=anchor aria-hidden=true href=#golang-and-javascript-promises>#</a></h3><p>JavaScript applications are single-threaded and leverage an event-loop strategy. Certain tasks might cause it to block, such as disk or network operations. JavaScript can schedule these operations by spinning processes off the event-loop, without blocking the main thread. A common way of doing<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises>it is through Promises</a>.</p><p>Golang HTTP calls are <a href=https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API>using JavaScript&rsquo;s <code>fetch</code></a> under the hood, for example. This results in a blocking operation (network call), which needs to be handled properly. Using <code>net/http</code> functions incorrectly will result in a runtime deadlock error. It is a common mistake, been even pointed out on the <a href=https://pkg.go.dev/syscall/js#FuncOf><code>syscall/js.FuncOf</code> documentation</a>:</p><blockquote><p>Invoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.</p><p>As a consequence, if one wrapped function blocks, JavaScript&rsquo;s event loop is blocked until that function returns. <strong>Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.</strong></p></blockquote><p>Starting goroutine solves event loop blocking. Image processing would definetely be a blocking operation and definitely be spun up in a goroutine. But, JavaScript doesn&rsquo;t &ldquo;understand&rdquo; them, and the application needs to signal JavaScript runtime to wait for its results. The easiest way is to create a <code>Promise</code> through <code>syscall/js</code> and call <code>resolve()</code> through the goroutine.</p><p>As it is a bit of a long piece of code, abstraction is vital. In ImageWand, this is dealt with through <a href=https://github.com/brunoluiz/imagewand/blob/main/jasm/wasm.go#L37-L57>the jasm.Await function</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Await</span>(<span style=color:#a6e22e>cb</span> <span style=color:#66d9ef>func</span>() (<span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#66d9ef>error</span>)) <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>handler</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>FuncOf</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>this</span> <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>args</span> []<span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolve</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>reject</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>args</span>[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This would be the function I want to deal with</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>res</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cb</span>()
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>reject</span>.<span style=color:#a6e22e>Invoke</span>(<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>resolve</span>.<span style=color:#a6e22e>Invoke</span>(<span style=color:#a6e22e>res</span>)
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>promiseJS</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>handler</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This way, any blocking operation can be created as a promise by wrapping it through this. There is a pull request open at <code>golang/go</code> <a href=https://github.com/golang/go/pull/52581>that implements a better version of this snippet</a>, perhaps landing in a future version of Go.</p><h2 id=optimisations>Optimisations<a hidden class=anchor aria-hidden=true href=#optimisations>#</a></h2><p>Once the proof of concept was up and running, there was a problem: binary size. At this point, building without any optimisation generated a 3.2Mb binary. Not ideal for mobile usage.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>GOOS<span style=color:#f92672>=</span>js GOARCH<span style=color:#f92672>=</span>wasm go build -o ./app/wasm/main-go.wasm ./cmd/wasm
</span></span></code></pre></div><p>The first optimisation one can do is to disable the injection of debugging information on build time through <code>ldflags</code>. For ImageWand, it reduced the binary to 3.1Mb (2%). Although quite low effort, it doesn&rsquo;t help much.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>GOOS<span style=color:#f92672>=</span>js GOARCH<span style=color:#f92672>=</span>wasm go build -o ./app/wasm/main-go-optimal.wasm -ldflags<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;-s -w&#34;</span> ./cmd/wasm
</span></span></code></pre></div><p>Tools like <a href=https://rustwasm.github.io/twiggy/><code>twiggy</code> can help analyse the binary size</a> as well. There wasn&rsquo;t much to tweak in this case, but I recommend giving it a try. The one that everyone recommends though, regardless of language, is <code>wasm-opt</code> from the <a href=http://webassembly.github.io/binaryen/><code>binaryen</code> toolchain</a>.</p><p>It allows many optimisations, but it requires a bit of tweaking per-project basis. After playing around with it, the previous optimised binary with <code>-Oz</code> produced the best results: a 2.9Mb binary, a 7% reduction compared to the original binary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wasm-opt -Oz -o ./app/wasm/main-go-optimal-binaryen.wasm ./app/wasm/main-go-optimal.wasm
</span></span></code></pre></div><p>With Golang compiler, this is as far as I could go with optimisations. Even considering Gzip, it didn&rsquo;t look great. It is not rare to find websites reaching 1Mb nowadays but, for such a simple project, 2.9Mb is unacceptable.</p><p><img alt="Go binary sizes" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/03-benchmark-go.png></p><center><small>Binary size per optimisation: no excessive gains, but still something</small></center><h2 id=tinygo-a-better-compiler-for-wasm>TinyGo: a better compiler for WASM?<a hidden class=anchor aria-hidden=true href=#tinygo-a-better-compiler-for-wasm>#</a></h2><p>I heard about <a href=https://tinygo.org/>TinyGo</a> sometime ago. With the slogan &ldquo;A Go Compiler For Small Places&rdquo; and a focus on embedded systems, I never got on the hype train. It is a subset of the Golang language, which means <a href=https://tinygo.org/docs/reference/lang-support/>there are some limitations</a> and not all packages will work on it, even the <a href=https://tinygo.org/docs/reference/lang-support/stdlib/>ones in the standard library</a>. This means it is not exactly a drop-in for all scenarios.</p><p>But, besides embedded systems, it seems to be a quite popular WASM compiler. The binaries produced, being a subset and focused on &ldquo;small places&rdquo;, are quite small. Taking into consideration the supported packages and limitations, it seemed a good candidate for ImageWand.</p><h3 id=almost-a-drop-in-replacement>Almost a drop-in replacement<a hidden class=anchor aria-hidden=true href=#almost-a-drop-in-replacement>#</a></h3><p>The first thing I tried was to compile the program using TinyGo, without any changes. It worked incredibly well, and the binary size dropped from ~3.2Mb to ~1.5Mb. Quite an improvement, especially when the WASM target is a web browser.</p><p>This was until I checked the console. Using <code>.String()</code> to get values from <code>syscall/js.Value</code> has not been implemented. Seemingly, ImageWand hit a TinyGo limitation and a hack around would be required.</p><br><p><img alt="TinyGo error" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/04-tinygo-error.png><br></p><p><a href=https://github.com/tinygo-org/tinygo/issues/1140>There are some hacks for it</a>, but they all have some memory leak issues. As the surface between the program functionality and <code>syscall/js</code> is quite limited, <a href=https://github.com/brunoluiz/imagewand/commit/4860cb4c757c0ad859912047eb145798d47ff434>changing those into <code>int</code> seemed a better solution (without any caveat)</a>.</p><p>Besides this, anyone attempting to move from Golang to TinyGo has to replace<a href=https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js><code>wasm_exec.js</code></a>. <a href=https://tinygo.org/docs/guides/webassembly/#how-it-works>According to the documentation</a>, it is based on the Go&rsquo;s one, but with a couple of changes that make it incompatible. Nothing major and super easy to tackle.</p><p>Once tweaked, ImageWand was successfully compiled using TinyGo, without any error messages in runtime and a binary twice the original size (1.5Mb). Smells like progress!</p><h3 id=tinygo-after-optimisations>TinyGo after optimisations<a hidden class=anchor aria-hidden=true href=#tinygo-after-optimisations>#</a></h3><p>Similar to Golang, the TinyGo compiler <a href=https://tinygo.org/docs/reference/usage/important-options/>allows tweaks</a> according to project requirements. Considering this will be distributed on the web, optimisations related to size are important. Some might prefer performance tweaks, which are available as well.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tinygo build -o app/wasm/main-tinygo-optimal.wasm -target wasm -no-debug -gc leaking ./cmd/wasm
</span></span><span style=display:flex><span>wasm-opt -Oz -o ./app/wasm/main-tinygo-optimal-binaryen.wasm ./app/wasm/main-tinygo-optimal.wasm
</span></span></code></pre></div><p>As in Golang though, <code>wasm-opt</code> did not result in a massive gain, but it is still something.</p><p><img alt="TinyGo binary sizes" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/05-benchmark-tinygo.png></p><center><small>TinyGo binary size per optimisation: drastic improvements when applying optimisations</small></center><br><p><img alt="TinyGo + Go binary sizes" loading=lazy src=/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/06-benchmark-all.png></p><center><small>Full binary size comparison from Golang to Tinygo + optimisations</small></center><br><p>If your implementation is compatible with TinyGo and you don&rsquo;t fall into an edge case, go for it! It provides plenty of features, and it seems a good choice in terms of binary size, especially considering web distribution.</p><h3 id=wasi-interesting-but-not-mature-enough-on-tinygo>WASI: interesting but not mature enough on TinyGo<a hidden class=anchor aria-hidden=true href=#wasi-interesting-but-not-mature-enough-on-tinygo>#</a></h3><p>At this point, ImageWand was working and it was not a large binary: I could call it a day. But, there was still one thing that I wanted to try out: <a href=https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-overview.md>WASI</a>.</p><blockquote><p>WASI stands for WebAssembly System Interface. It&rsquo;s an API designed by the Wasmtime project that provides access to several operating-system-like features, including files and filesystems, Berkeley sockets, clocks, and random numbers, that we&rsquo;ll be proposing for standardisation.</p><p><strong>It&rsquo;s designed to be independent of browsers, so it doesn&rsquo;t depend on Web APIs or JS, and isn&rsquo;t limited by the need to be compatible with JS</strong>. And it has integrated capability-based security, so it extends WebAssembly&rsquo;s characteristic sandboxing to include I/O.</p></blockquote><p><small>‚ÑπÔ∏è <a href=https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/>There is an interesting article from MDN</a> about the subject ‚Äì It is something I definitely want to dive deeper into in the future</small></p><p>ImageWand was relying on <code>syscall/js</code> to interface with user input, which depends on JavaScript APIs, and it wouldn&rsquo;t run in any other runtime besides the browser. Binaries compiled into the WASI standard though can be run anywhere that implements its specification: browser, terminal or within other backends (serverless function with NodeJS running Golang WASI bins). Yes, &ldquo;Build once, run everywhere&rdquo; <del>Java</del> vibes.</p><p>TinyGo supports WASI. This means <code>syscall/js</code> is not required if you don&rsquo;t want to manipulate the DOM, which would have made ImageWand code simpler, becoming just an exported Golang function‚Ä¶ But, there are a couple of limitations when implementing WASI programs with TinyGo:</p><ol><li><a href="https://tinygo.org/docs/concepts/compiler-internals/calling-convention/#:~:text=The%20WebAssembly%20target%20does%20not%20return%20variables%20directly%20that%20cannot%20be%20handled%20by%20JavaScript%20(see%20above%20about%20i64%2C%20also%20struct%2C%20i64%2C%20multiple%20return%20values%2C%20etc).%20Instead%2C%20they%20are%20stored%20into%20a%20pointer%20passed%20as%20the%20first%20parameter%20by%20the%20caller.">Function arguments and outputs can only be numbers or pointers, which are essentially numbers with a memory address</a>.</li><li><a href=https://github.com/tinygo-org/tinygo/issues/3010#issuecomment-1191916589>There is no proper support for multi-return, so no easy <code>(someType, error)</code></a> without some hacks.</li><li>Lacking documentation and helper methods to operate on top of shared WASM memory (<a href=https://github.com/tinygo-org/tinygo/issues/3040>I&rsquo;ve opened a ticket around documentation</a>).</li></ol><p>ImageWand was passing a slice of <code>byte</code> with the image content, which was the simplest way to get this working (don&rsquo;t io.Reader me: it is not as simple). To pass the image input and receive the output in <code>[]byte</code>, you need to use JavaScript and WASM shared memory space, pointers and all sort of low-level magic.</p><p>Checking Github, it seems many people came across the issue of passing non-numeric values or returning multiple values, and every developer has a different solution to it <a href=https://github.com/tinygo-org/tinygo/issues/2512#issuecomment-1011399751>[1]</a> <a href=https://github.com/tinygo-org/tinygo/issues/1824>[2]</a>.<a href=https://github.com/brunoluiz/imagewand/pull/4>Eventually, I came up with my way of dealing with this</a>, but it is quite ugly and probably not efficient at all. Most likely I should have used <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory><code>WebAssembly.memory.buffer</code></a>, but I couldn&rsquo;t find an easy way of doing so. Besides, WASI was an extra in this whole experiment and, at this point, I had invested a long time cracking my head to have at least something minimal working.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#75715e>// JavaScript code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#a6e22e>buf</span>).<span style=color:#a6e22e>forEach</span>((<span style=color:#a6e22e>b</span>) =&gt; <span style=color:#a6e22e>imagewand</span>.<span style=color:#a6e22e>appendToBuffer</span>(<span style=color:#a6e22e>b</span>));
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>imagewand</span>.<span style=color:#a6e22e>convertFromBlob</span>(<span style=color:#a6e22e>formatToNumber</span>(<span style=color:#a6e22e>format</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>outputSize</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>imagewand</span>.<span style=color:#a6e22e>getOutputSize</span>();
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>arrayBuffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Uint8Array</span>(<span style=color:#a6e22e>outputSize</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>outputSize</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>arrayBuffer</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>imagewand</span>.<span style=color:#a6e22e>getOutputAtPos</span>(<span style=color:#a6e22e>i</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Golang code</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>image</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>input</span> <span style=color:#a6e22e>image</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>output</span> <span style=color:#a6e22e>image</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//export appendToBuffer</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>appendToBuffer</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>byte</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span> = append(<span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//export getOutputSize</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getOutputSize</span>() <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> len(<span style=color:#a6e22e>output</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//export getOutputAtPos</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getOutputAtPos</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>output</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Other stuff</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//export convertFromBlob</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>convertFromBlob</span>(<span style=color:#a6e22e>format</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>img</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>imagewand</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>(<span style=color:#a6e22e>input</span>))
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fileFormatFromInt</span>[<span style=color:#a6e22e>format</span>]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#e6db74>&#34;format not supported&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>NewBuffer</span>([]<span style=color:#66d9ef>byte</span>{})
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>img</span>.<span style=color:#a6e22e>Convert</span>(<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>f</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>output</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>()
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span> = []<span style=color:#66d9ef>byte</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>These limitations and lack of documentation around WASI, workarounds and common examples for TinyGo make it quite hard to abandon <code>syscall/js</code> for browser apps or use it for non-JS WASM applications. Although I managed to make it work, I wouldn&rsquo;t recommend someone to drop <code>syscall/js</code> in favour of WASI TinyGo for browser applications at the moment, only if the person wants to deep dive and study its details. If you decide to do so, please help the community by adding examples, tutorials and documentation to the official project page.</p><h2 id=conclusions-on-using-golang-with-wasm>Conclusions on using Golang with WASM<a hidden class=anchor aria-hidden=true href=#conclusions-on-using-golang-with-wasm>#</a></h2><p>Being able to re-use and compile Golang code into WASM is exciting. Besides, for those used to Golang as their daily driver, it might be a natural choice when considering complex applications.</p><p>In general, I always recommend Golang due its tooling. But, for WASM, my experience was quite bumpy:</p><ul><li>The final binary size using Golang toolchain (around 3.2Mb) might be OK for the backend but not for frontend apps. This adds up when considering network outbound costs or slow mobile connections.</li><li>TinyGo is an amazing alternative, but you might fall into edge-cases or unsupported features. This is quite an annoyance but, if you manage to get your way around it, it is probably the perfect choice for your Golang WASM project.</li><li>CI pipelines will get more complex as Golang/TinyGo tooling needs to be handled, and <a href=https://github.com/brunoluiz/imagewand/blob/v1.0.0/.github/workflows/deploy.yaml>extra build steps are required</a>. Not that JavaScript toolchain is not complex by itself already.</li><li>The use of <code>syscall/js</code> is quite cumbersome and unsafe, but mostly because of the JavaScript nature.</li><li>Dealing with DOM elements is possible, but changing UI elements is quite a painful and complex task. Try to limit its use only as glue.</li><li>Golang WASM is an independent and experimental port. <a href=https://github.com/golang/go/issues/53383>There are discussions on how to deal with such ports</a>, but it is something to bear in mind. Besides, as it is still not a stable API, it might change at any point (although it never changed since its release).</li><li>WASI support is Golang does not exist at the moment, and TinyGo is not the most ergonomic in terms of WASI development, with a lack of documentation and examples. This can be mostly due to the WASI specification, as it is still in progress, but things like <code>wasm-bindgen</code> for Rust prove that it could be somehow possible.</li></ul><p>Would I choose Golang for a WASM project? If I had to develop something quickly or the people involved are used to Golang, definitely yes (TinyGo, to be fair). But I feel it is not the best choice in terms of features, documentation, toolchain and support. C/C++ and Rust seem to lead the way.</p><p>I never programmed with Rust before, but considering its support to WASM and some other interesting use cases I have in mind, it is perhaps a sign that I should finally try to learn it.</p><ul><li><a href=https://imagewand.concordalabs.com>üîó ImageWand project page</a></li><li><a href=https://github.com/brunoluiz/imagewand>üíæ ImageWand source code</a></li><li><a href=https://twitter.com/brunoluiz>üí¨ Reach me on Twitter @ brunoluiz</a></li></ul><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><ol><li><a href=https://withblue.ink/2020/10/03/go-webassembly-http-requests-and-promises.html>Go, WebAssembly, HTTP requests and Promises</a></li><li><a href=https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects>MDN: Transferable objects</a></li><li><a href=https://qvault.io/golang/running-go-in-the-browser-wasm-web-workers/>Running Go in the Browser with WASM and Web Workers</a></li><li><a href=https://www.sitepen.com/blog/using-webassembly-with-web-workers>Using WebAssembly with Web Workers</a></li><li><a href=https://www.fermyon.com/blog/optimizing-tinygo-wasm>Shrink Your TinyGo WebAssembly Modules by 60%</a></li><li><a href=https://elewis.dev/are-we-wasm-yet-part-1>Are We Wasm Yet ? - Part 1</a></li><li><a href=https://elewis.dev/are-we-wasm-yet-part-2#heading-server-implementation>Are We Wasm Yet ? - Part 2</a></li><li><a href=https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/>Standardizing WASI: A system interface to run WebAssembly outside the web</a></li><li><a href=https://wasi.dev/>WASI</a></li><li><a href=https://wasmbyexample.dev/examples/webassembly-linear-memory/webassembly-linear-memory.go.en-us.html#>WebAssembly Linear Memory example</a></li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/2022/nov/low-downtime-postgres-upgrade-i-want-to-believe/><span class=title>¬´ Prev</span><br><span>Low downtime Postgres upgrade: I want to believe (part I)</span>
</a><a class=next href=https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/><span class=title>Next ¬ª</span><br><span>GIFs (sane) playback control using WASM and FFmpeg</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>