<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>GIFs (sane) playback control using WASM and FFmpeg | Bruno Luiz Silva</title><meta name=keywords content><meta name=description content="Not having playback control on GIFs always annoyed me a bit. I always secretly hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands."><meta name=author content><link rel=canonical href=https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/><link crossorigin=anonymous href=/assets/css/stylesheet.1d044a8ae143a71443a33febc372f95f5ce9087d07078feec050ae02388800f5.css integrity="sha256-HQRKiuFDpxRDoz/rw3L5X1zpCH0HB4/uwFCuAjiIAPU=" rel="preload stylesheet" as=style><link rel=icon href=https://brunoluiz.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://brunoluiz.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://brunoluiz.net/favicon-32x32.png><link rel=apple-touch-icon href=https://brunoluiz.net/apple-touch-icon.png><link rel=mask-icon href=https://brunoluiz.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/"><meta property="og:site_name" content="Bruno Luiz Silva"><meta property="og:title" content="GIFs (sane) playback control using WASM and FFmpeg"><meta property="og:description" content="Not having playback control on GIFs always annoyed me a bit. I always secretly hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-01-20T12:00:00+00:00"><meta property="article:modified_time" content="2022-01-20T12:00:00+00:00"><meta property="og:image" content="https://brunoluiz.net/cover.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://brunoluiz.net/cover.jpg"><meta name=twitter:title content="GIFs (sane) playback control using WASM and FFmpeg"><meta name=twitter:description content="Not having playback control on GIFs always annoyed me a bit. I always secretly hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://brunoluiz.net/blog/"},{"@type":"ListItem","position":2,"name":"GIFs (sane) playback control using WASM and FFmpeg","item":"https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"GIFs (sane) playback control using WASM and FFmpeg","name":"GIFs (sane) playback control using WASM and FFmpeg","description":"Not having playback control on GIFs always annoyed me a bit. I always secretly hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands.","keywords":[],"articleBody":"Animated images in GIF format are around for a long time. They were first released in 1987 by CompuServe. Yep, your maths are correct: they came even before browsers. It was not until Netscape 2.0 that the GIF format was incorporated and conquered the world (really).\nThey are everywhere: from memes to artsy GIFs, they come in all shapes and formats. The software engineering world adopted them for a particular use case: recording tutorials and demos.\nMarkdown probably is to blame here. Embedding a GIF into your Github page, static blog or NPM package, which tend to use Markdown, is the easiest way to embed a ‚Äúvideo-like‚Äù component: ![](./img.gif) and all good.\nGIFs are ominous nowadays, being more popular than even newer and more efficient formats, such as WEBP or APNG. But, depending on their length and what has been recorded, you might want to pause, go back, jump sections etc. Video playback features basically‚Ä¶ which GIFs don‚Äôt have.\nNot having this feature always annoyed me a bit. I always secretly hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands.\nBrowser extensions: a ticket to heaven? Some time ago, I was a bit annoyed with Grammarly. As a non-native English speaker, it helps me a lot when writing technical documents or blog posts. But these documents had to be exported to Markdown.\nAt some point, I got annoyed by the lack of this feature, and I decided to create a browser extension to solve that: Grammarly to Markdown (GitHub). This was 2019, and I still use it nowadays.\nThen, last year, James Long published A future for SQL on the web, where he describes how to use SQLite in the browser. ‚ÄúSQLite, in the browser!? How!?‚Äù you may ask. Well, dear friend, there is this magical thing called WebAssembly. In this case, it allows JavaScript to interoperate with libraries and programs written in other languages, such as SQLite.\nI already knew about the existence of WASM, but this post was eye-opening. I realised it opens many interesting possibilities and, during my search for other projects, I came across FFmpeg.wasm.\nAt some point last year, my annoyance with GIFs came about again. I tried some extensions, but the UI and UX were never that friendly. I was expecting something like HTML playback control.\nWith my ‚Äúfresh‚Äù knowledge about WASM, I thought: wait a second, what if I created a browser extension that converted GIFs into videos using FFMPEG!? Guess what: I did it again.\nFFmpeg.wasm + Browser Extension: GIFSane Fun fact: the demo above is in WebP, so GIF wouldn‚Äôt be able to convert ü§∑\nAfter a couple of weeks of hacking things, I managed to put together GIFSane. It allows users to either convert and replace the image component or download the converted result straight (QuickTime can‚Äôt open it though). For now, I can‚Äôt publish in Chrome Web Store (more details on sections ahead), but you can still load it manually (instructions on the repository).\nIt is not as fast as a ‚Äúbare-metal‚Äù FFmpeg (no hardware acceleration) but is way more convenient. Besides, it was a great opportunity to learn more about WebAssembly.\nCreating extensions, however, can always be tricky. There are lots of caveats, tricks and not properly documented APIs. It is certainly not an easy and quick project to hack around. Besides, FFmpeg.wasm has its own set of limitations (or rather WASM itself).\nHere be dragons: extensions using WASM and FFmpeg Differently from frontend and backend, where there are lots of materials, tutorials and frameworks, extensions are quite the opposite.\nI will not go through the whole implementation. Instead, I will go through my main learnings in this project, mostly around WASM and FFmpeg. The extension itself is simply architected, and you can explore it at GitHub.\nManifest V3 vs V2 (January 2022): limitations everywhere Manifest V3 will be a requirement from January 2023 onwards. If you want to publish an extension to Chrome Web Store, be aware that only Manifest V3 is accepted currently.\nChrome-based engines are the only ones supporting it, while Firefox is still on Manifest V2. This means that you might have to support two versions of the same extension. Mozilla is supposed to release its implementation soon, but it seems there will be divergences.\nFor GIFSane though, I couldn‚Äôt even use Manifest V3. As of January 2022, it still does not support WASM. Developers who want to build on top of WASM still need to wait. Hence why it is not available on Chrome Web Store.\nBesides, background scripts need to be migrated to service workers. Depending on the implementation, this might be tricky. FFmpeg.wasm, for one, uses [URL.createObjectURL()][14] and document.\\* in its browser version, both not available in workers.\nSharedArrayBuffer \u0026 SPECTRE To make use of multi-threading, applications compiled with WASM require SharedArrayBuffer. But, since SPECTRE (the security vulnerability, not the Bond movie), this has been a minefield for browsers.\nAll major browsers disabled it at the start of 2018, only re-enabling it in 2020. If you want a website to use this, you need to set Cross-Origin-Opener-Policy and Cross-Origin-Embedder-Policy headers. Extensions have to set those as well to be able to use WASM.\nThe caveat is that, on Firefox, extensions can‚Äôt use SharedArrayBuffer. Only a few privileged extensions can, which forbids the usage of multi-threaded WASM extensions on Firefox.\nSingle-threaded FFmpeg.wasm is possible üöÄ On the bright side: WASM applications can be compiled to single-threaded, and FFMPEG.wasm is no different. It removes the need for SharedArrayBuffer with the only caveat being it will be certainly slower.\nAs of January 2022, there is no ‚Äúpre-packaged‚Äù FFMPEG.wasm available with single-threaded support. But @jeromewu already pushed the required changes to compile it. This means you will need to get your hands a little bit dirty.\nBuild ffmpeg.wasm-core\nYou can build manually by heading to https://github.com/ffmpegwasm/ffmpeg.wasm-core and following the instructions. Or, you can use GitHub Actions in your favour:\nFork the project: https://github.com/ffmpegwasm/ffmpeg.wasm-core Enable the GitHub Actions (just go to the Actions tab) Push a dummy commit There should be two workflows running in your GitHub Actions: select Build FFmpeg.wasm (Single Thread) It will take ages to compile: go make a coffee ‚òïÔ∏è Once finished, download the artefacts (bottom of the page) Now you should have a working single-thread version of it.\nBuild ffmpeg.wasm\nIf you change the corePath param of createFFmpeg to use the single-threaded version, you will realise that it still does not work. Worse: now it errors with:\n[fferr] Assertion failed: Cannot call unknown function proxy_main, make sure it is exported Uncaught (in promise) RuntimeError: abort(Assertion failed: Cannot call unknown function proxy_main, make sure it is exported). Build with -s ASSERTIONS=1 for more info. When you build without multi-threading, proxy_main is not published anymore. From what I understood, this is because proxy_main is used as a ‚Äúproxy‚Äù entry point by ECMScripten when dealing with multi-threading + workers just so it doesn‚Äôt block the main thread (more details here). With the single-threaded binary, this proxy will not be available. Instead, you should use main.\nThere is a fix for this already, but it still hasn‚Äôt been merged. Guess what: time to get your hands dirty again:\nFork the project: https://github.com/ffmpegwasm/ffmpeg.wasm Apply the patches from https://github.com/ffmpegwasm/ffmpeg.wasm/pull/235/files Build the package with npm ci \u0026\u0026 npm build (no coffee this time, it is quick to compile) You can now use the single-threaded FFmpeg.wasm in your project:\nconst ffmpeg = createFFmpeg({ corePath: './/ffmpeg-core.js', mainName: 'main' }); If you want your extension to support both, you will have to keep both WASM files and change things in build time (I used symbolic links). You need to detect the browser and change the mainName entry point during run-time (a bit tricky in extensions).\nNo MP4/H.264 support on Firefox Firefox does not include the required codecs to play MP4 (H.264). I always thought it got open-sourced at some point, but I was clearly too naive. Instead, they recommend WebM (VP9).\nFFmpeg.wasm supports both. But, there is a catch: GIF to WebM encoding is slower than MP4‚Äôs. Sadly, Firefox users have a double performance penalty with FFmpeg.wasm. Either way, slow is better than nothing, and GIFSane supports WebM encoding as well.\nDealing with CSP headers to inject Blobs (FFmpeg output) in any page Initially, GIFSane used a content script to run FFmpeg. But:\nIt was inefficient, as all pages loaded GIFSane resources (mainly ffmpeg.wasm) Some websites [Content Security Policy][30] block any content injection to it. GitHub is quite aggressive in these policies, for example. Once FFmpeg.wasm was moved to a background script, I managed to run FFmpeg and convert GIFs. It still required a hack to pass the final MP4 from the background to the content script. This is because extensions don‚Äôt emit JS objects, but stringified versions of them instead. I obviously found my way ü§∑ (exhibit A, exhibit B).\nBut, even with this workaround, I couldn‚Äôt inject the blob into the page. Some websites declare media-src in their CSP headers, which blocks media injection (like blobs). Another duct tape hack had to be applied, with a little help from chrome.webRequest.onHeadersReceived.\nWith this API, the onHeadersReceived is called once the page HTTP Headers are received. GIFSane reads them and changes them just a tiny bit: it adds blob: to the CSP media-src. After that, the GIFSane content script can replace the GIF with the FFmpeg output. I am not sure if this is a reason for security concerns, but it was my only way around it (please, ping me on Twitter if it is).\nFinal words Creating GIFSane was an interesting challenge. I now want to go deeper into WASM and perhaps convert a project myself (I am open to ideas).\nBecause it doesn‚Äôt have hardware acceleration, it is a bit slow at times. As long as developers don‚Äôt push 5 minutes GIFs, FFmpeg.wasm should be enough. If not, I might create an external agent which calls a bare-metal FFmpeg.\nCloser to the end of the year, I will revisit this post and GIFSane due to Manifest V3 migrations. Expect a Part II soon üëÄ\nüîó GIFSane project page üí¨ Reach me on Twitter @ brunoluiz ","wordCount":"1699","inLanguage":"en","image":"https://brunoluiz.net/cover.jpg","datePublished":"2022-01-20T12:00:00Z","dateModified":"2022-01-20T12:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/"},"publisher":{"@type":"Organization","name":"Bruno Luiz Silva","logo":{"@type":"ImageObject","url":"https://brunoluiz.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://brunoluiz.net/ accesskey=h title="Bruno Luiz Silva (Alt + H)">Bruno Luiz Silva</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">GIFs (sane) playback control using WASM and FFmpeg</h1><div class=post-meta><span title='2022-01-20 12:00:00 +0000 UTC'>January 20, 2022</span>&nbsp;¬∑&nbsp;8 min</div></header><figure class=entry-cover><img loading=eager srcset='https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover_hu_c14fde4fb3c8830.jpg 360w,https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover_hu_258dca739caf44cc.jpg 480w,https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover_hu_2723463f39bd49bf.jpg 720w,https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover_hu_fa345383e7befaa3.jpg 1080w,https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover_hu_d664e0bff11e0072.jpg 1500w,https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover.jpg 1920w' src=https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/cover.jpg sizes="(min-width: 768px) 720px, 100vw" width=1920 height=1080 alt="Photo by Stephen Monterroso on Unsplash"><figcaption><a href=https://unsplash.com/photos/cwcPV_VKfy4>Photo by Stephen Monterroso on Unsplash</a></figcaption></figure><div class=post-content><p>Animated images in GIF format are around for a long time. They were first released in 1987 by CompuServe. Yep, your maths are correct: they came even before browsers. It was not until Netscape 2.0 that the GIF format was incorporated and conquered the world (<a href=https://www.vox.com/culture/2017/6/15/15802136/gif-turns-30-evolution-internet-history>really</a>).</p><p>They are everywhere: from memes to artsy GIFs, they come in all shapes and formats. The software engineering world adopted them for a particular use case: recording tutorials and demos.</p><p>Markdown probably is to blame here. Embedding a GIF into your Github page, static blog or NPM package, which tend to use Markdown, is the easiest way to embed a &ldquo;video-like&rdquo; component: <code>![](./img.gif)</code> and all good.</p><p>GIFs are ominous nowadays, being more popular than even newer and more efficient formats, such as <a href=https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#webp_image>WEBP</a> or <a href=https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types#apng_animated_portable_network_graphics>APNG</a>. But, depending on their length and what has been recorded, you might want to pause, go back, jump sections etc. Video playback features basically&mldr; which GIFs don&rsquo;t have.</p><p>Not having this feature always annoyed me a bit. I always <em>secretly</em> hoped that one day browsers would support this. This day never arrived, and I decided to take matters into my own hands.</p><h2 id=browser-extensions-a-ticket-to-heaven>Browser extensions: a ticket to heaven?<a hidden class=anchor aria-hidden=true href=#browser-extensions-a-ticket-to-heaven>#</a></h2><p>Some time ago, I was a bit annoyed with Grammarly. As a non-native English speaker, it helps me a lot when writing technical documents or blog posts. But these documents had to be exported to Markdown.</p><p>At some point, I got annoyed by the lack of this feature, and I decided to create a browser extension to solve that: <a href=https://brunoluiz.net/grammarly-markdown-extension/>Grammarly to Markdown</a> (<a href=https://github.com/brunoluiz/grammarly-markdown-extension>GitHub</a>). This was 2019, and I still use it nowadays.</p><p>Then, last year, James Long published <a href=https://jlongster.com/future-sql-web><em>A future for SQL on the web</em></a>, where he describes how to use SQLite in the browser. &ldquo;SQLite, in the browser!? How!?&rdquo; you may ask. Well, dear friend, there is this magical thing called <a href=https://developer.mozilla.org/en-US/docs/WebAssembly/Concepts><em>WebAssembly</em></a>. In this case, it allows JavaScript to interoperate with libraries and programs written in other languages, such as SQLite.</p><p>I already knew about the existence of WASM, but this post was eye-opening. I realised it opens many interesting possibilities and, during my search for other projects, I came across <a href=https://github.com/ffmpegwasm/ffmpeg.wasm>FFmpeg.wasm</a>.</p><p>At some point last year, my annoyance with GIFs came about again. I tried some extensions, but the UI and UX were never that friendly. I was expecting something like HTML playback control.</p><p>With my &ldquo;<em>fresh&rdquo;</em> knowledge about WASM, I thought: wait a second, what if I created a browser extension that converted GIFs into videos using FFMPEG!? Guess what: I did it again.</p><h2 id=ffmpegwasm--browser-extension-gifsane>FFmpeg.wasm + Browser Extension: GIFSane<a hidden class=anchor aria-hidden=true href=#ffmpegwasm--browser-extension-gifsane>#</a></h2><p><img loading=lazy src=/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/demo.webp></p><p><em>Fun fact: the demo above is in WebP, so GIF wouldn&rsquo;t be able to convert ü§∑</em></p><p>After a couple of weeks of hacking things, I managed to put together <a href=https://github.com/brunoluiz/gifsane-extension>GIFSane</a>. It allows users to either convert and replace the image component or download the converted result straight (QuickTime can&rsquo;t open it though). For now, I can&rsquo;t publish in Chrome Web Store (more details on sections ahead), but you can still load it manually (instructions on the repository).</p><p>It is not as fast as a &ldquo;bare-metal&rdquo; FFmpeg (no hardware acceleration) but is way more convenient. Besides, it was a great opportunity to learn more about WebAssembly.</p><p>Creating extensions, however, can always be tricky. There are lots of caveats, tricks and not properly documented APIs. It is certainly not an easy and quick project to hack around. Besides, FFmpeg.wasm has its own set of limitations (or rather WASM itself).</p><h2 id=here-be-dragons-extensions-using-wasm-and-ffmpeg>Here be dragons: extensions using WASM and FFmpeg<a hidden class=anchor aria-hidden=true href=#here-be-dragons-extensions-using-wasm-and-ffmpeg>#</a></h2><p>Differently from frontend and backend, where there are lots of materials, tutorials and frameworks, extensions are quite the opposite.</p><p>I will not go through the whole implementation. Instead, I will go through my main learnings in this project, mostly around WASM and FFmpeg. The extension itself is simply architected, and you can <a href=https://github.com/brunoluiz/gifsane-extension>explore it at GitHub</a>.</p><h3 id=manifest-v3-vs-v2-january-2022-limitations-everywhere>Manifest V3 vs V2 (January 2022): limitations everywhere<a hidden class=anchor aria-hidden=true href=#manifest-v3-vs-v2-january-2022-limitations-everywhere>#</a></h3><p>Manifest V3 will be a requirement from January 2023 onwards. If you want to publish an extension to Chrome Web Store, be aware that only Manifest V3 is accepted currently.</p><p>Chrome-based engines are the only ones supporting it, while Firefox is still on Manifest V2. This means that you might have to support two versions of the same extension. <a href=https://blog.mozilla.org/addons/2021/05/27/manifest-v3-update/>Mozilla is supposed to release its implementation soon</a>, but it seems there will be divergences.</p><p>For GIFSane though, I couldn&rsquo;t even use Manifest V3. As of January 2022, <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1173354">it still does not support WASM</a>. Developers who want to build on top of WASM still need to wait. Hence why it is not available on Chrome Web Store.</p><p>Besides, background scripts <a href=https://developer.chrome.com/docs/extensions/mv3/intro/mv3-overview/#service-workers>need to be migrated to service workers.</a> Depending on the implementation, this might be tricky. FFmpeg.wasm, for one, uses <code>[URL.createObjectURL()][14]</code> and <code>document.\*</code> in its browser version, both not available in workers.</p><h3 id=sharedarraybuffer--spectre>SharedArrayBuffer & SPECTRE<a hidden class=anchor aria-hidden=true href=#sharedarraybuffer--spectre>#</a></h3><p>To make use of multi-threading, applications compiled with WASM require <code>SharedArrayBuffer</code>. But, since <a href=https://meltdownattack.com/>SPECTRE</a> (the security vulnerability, not the Bond movie), this has been a minefield for browsers.</p><p>All major browsers <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer#security_requirements>disabled it at the start of 2018</a>, only re-enabling it in 2020. If you want a website to use this, you need to set <code>Cross-Origin-Opener-Policy</code> and <code>Cross-Origin-Embedder-Policy</code> headers. <a href=https://developer.chrome.com/docs/extensions/mv2/manifest/cross_origin_embedder_policy/>Extensions have to set those as well</a> to be able to use WASM.</p><p>The caveat is that, on Firefox, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1674383">extensions can&rsquo;t use <code>SharedArrayBuffer</code></a>. Only a few <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1674383#c33">privileged extensions can</a>, which forbids the usage of multi-threaded WASM extensions on Firefox.</p><h3 id=single-threaded-ffmpegwasm-is-possible->Single-threaded FFmpeg.wasm is possible üöÄ<a hidden class=anchor aria-hidden=true href=#single-threaded-ffmpegwasm-is-possible->#</a></h3><p><img alt="Photo by Michael Dziedzic on Unsplash" loading=lazy src=/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/fixing.jpg></p><p>On the bright side: WASM applications can be compiled to single-threaded, and FFMPEG.wasm is no different. It removes the need for <code>SharedArrayBuffer</code> with the only caveat being it will be certainly slower.</p><p>As of January 2022, there is no &ldquo;pre-packaged&rdquo; FFMPEG.wasm available with single-threaded support. But <a href=https://github.com/jeromewu>@jeromewu</a> already pushed the required changes to compile it. This means you will need to get your hands a little bit dirty.</p><p><strong>Build <code>ffmpeg.wasm-core</code></strong></p><p>You can build manually by heading to <a href=https://github.com/ffmpegwasm/ffmpeg.wasm-core>https://github.com/ffmpegwasm/ffmpeg.wasm-core</a> and following the instructions. Or, you can use GitHub Actions in your favour:</p><ul><li>Fork the project: <a href=https://github.com/ffmpegwasm/ffmpeg.wasm-core>https://github.com/ffmpegwasm/ffmpeg.wasm-core</a></li><li>Enable the GitHub Actions (just go to the Actions tab)</li><li>Push a dummy commit</li><li>There should be two workflows running in your GitHub Actions: select <code>Build FFmpeg.wasm (Single Thread)</code></li><li>It will take ages to compile: go make a coffee ‚òïÔ∏è</li><li>Once finished, download the artefacts (bottom of the page)</li></ul><p>Now you should have a working single-thread version of it.</p><p><strong>Build <code>ffmpeg.wasm</code></strong></p><p>If you change the <code>corePath</code> param of <code>createFFmpeg</code> to use the single-threaded version, you will realise that it still does not work. Worse: now it errors with:</p><pre tabindex=0><code>[fferr] Assertion failed: Cannot call unknown function proxy_main, make sure it is exported
Uncaught (in promise) RuntimeError: abort(Assertion failed: Cannot call unknown function proxy_main, make sure it is exported). Build with -s ASSERTIONS=1 for more info.
</code></pre><p>When you build without multi-threading, <code>proxy_main</code> is not published anymore. From what I understood, this is because <code>proxy_main</code> is used as a &ldquo;proxy&rdquo; entry point by ECMScripten when dealing with multi-threading + workers just so it doesn&rsquo;t block the main thread (<a href=https://emscripten.org/docs/porting/pthreads.html>more details here</a>). With the single-threaded binary, this proxy will not be available. Instead, you should use <code>main</code>.</p><p>There <a href=https://github.com/ffmpegwasm/ffmpeg.wasm/pull/235>is a fix for this already</a>, but it still hasn&rsquo;t been merged. Guess what: time to get your hands dirty again:</p><ul><li>Fork the project: <a href=https://github.com/ffmpegwasm/ffmpeg.wasm-core>https://github.com/ffmpegwasm/ffmpeg.wasm</a></li><li>Apply the patches from <a href=https://github.com/ffmpegwasm/ffmpeg.wasm/pull/235/files>https://github.com/ffmpegwasm/ffmpeg.wasm/pull/235/files</a></li><li>Build the package with <code>npm ci && npm build</code> (no coffee this time, it is quick to compile)</li></ul><p>You can now use the single-threaded FFmpeg.wasm in your project:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ffmpeg</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createFFmpeg</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>corePath</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;./&lt;path-to-ffmpeg-core-dist&gt;/ffmpeg-core.js&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mainName</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;main&#39;</span>
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>If you want your extension to support both, you will have to keep both WASM files and change things in build time (<a href=https://github.com/brunoluiz/gifsane-extension/blob/main/package.json#L8-L9>I used symbolic links</a>). You need to detect the browser and change the <code>mainName</code> entry point during run-time (<a href=https://github.com/brunoluiz/gifsane-extension/blob/main/src/handlers/ffmpeg-handler.js#L1-L9>a bit tricky in extensions</a>).</p><h3 id=no-mp4h264-support-on-firefox>No MP4/H.264 support on Firefox<a hidden class=anchor aria-hidden=true href=#no-mp4h264-support-on-firefox>#</a></h3><p><a href=https://support.mozilla.org/en-US/kb/html5-audio-and-video-firefox#w_patented-media>Firefox does not include the required codecs to play MP4 (H.264)</a>. I always thought it got open-sourced at some point, but I was clearly too naive. Instead, they recommend WebM (VP9).</p><p>FFmpeg.wasm supports both. But, there is a catch: GIF to WebM encoding is slower than MP4&rsquo;s. Sadly, Firefox users have a double performance penalty with FFmpeg.wasm. Either way, slow is better than nothing, and GIFSane supports WebM encoding as well.</p><h3 id=dealing-with-csp-headers-to-inject-blobs-ffmpeg-output-in-any-page>Dealing with CSP headers to inject Blobs (FFmpeg output) in any page<a hidden class=anchor aria-hidden=true href=#dealing-with-csp-headers-to-inject-blobs-ffmpeg-output-in-any-page>#</a></h3><p>Initially, GIFSane used a content script to run FFmpeg. But:</p><ol><li>It was inefficient, as all pages loaded GIFSane resources (mainly ffmpeg.wasm)</li><li>Some websites <code>[Content Security Policy][30]</code> block any content injection to it. GitHub is quite aggressive in these policies, for example.</li></ol><p>Once FFmpeg.wasm was moved to a background script, I managed to run FFmpeg and convert GIFs. It still required a hack to pass the final MP4 from the background to the content script. This is because extensions don&rsquo;t emit JS objects, but stringified versions of them instead. I obviously found my way ü§∑ (<a href=https://github.com/brunoluiz/gifsane-extension/blob/main/src/handlers/ffmpeg-handler.js#L71-L78>exhibit A</a>, <a href=https://github.com/brunoluiz/gifsane-extension/blob/main/src/content.js#L49-L50>exhibit B</a>).</p><p>But, even with this workaround, I couldn&rsquo;t inject the blob into the page. Some websites declare <code>media-src</code> in their CSP headers, which blocks media injection (like blobs). Another <del>duct tape</del> hack had to be applied, with a little help from <code>chrome.webRequest.onHeadersReceived</code>.</p><p>With this API, the <code>onHeadersReceived</code> is called once the page HTTP Headers are received. GIFSane reads them and changes them just a tiny bit: <a href=http://chrome.webRequest.onHeadersReceived>it adds <code>blob:</code> to the CSP <code>media-src</code></a>. After that, the GIFSane content script can replace the GIF with the FFmpeg output. I am not sure if this is a reason for security concerns, but it was my only way around it (please, <a href=https://twitter.com/brunoluiz>ping me on Twitter</a> if it is).</p><h2 id=final-words>Final words<a hidden class=anchor aria-hidden=true href=#final-words>#</a></h2><p><img alt="Photo by Javier Allegue Barros on Unsplash" loading=lazy src=/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/conclusion.jpg></p><p>Creating GIFSane was an interesting challenge. I now want to go deeper into WASM and perhaps convert a project myself (I am open to ideas).</p><p>Because it doesn&rsquo;t have hardware acceleration, it is a bit slow at times. As long as developers don&rsquo;t push 5 minutes GIFs, FFmpeg.wasm should be enough. If not, I might create an external agent which calls a bare-metal FFmpeg.</p><p>Closer to the end of the year, I will revisit this post and GIFSane due to Manifest V3 migrations. Expect a Part II soon üëÄ</p><ul><li><a href=https://github.com/brunoluiz/gifsane>üîó GIFSane project page</a></li><li><a href=https://twitter.com/brunoluiz>üí¨ Reach me on Twitter @ brunoluiz</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://brunoluiz.net/blog/2022/aug/imagewand-privacy-first-image-conversion-experiment-with-golang-and-wasm/><span class=title>¬´ Prev</span><br><span>ImageWand: privacy-first image conversion experiment with Golang & WASM</span>
</a><a class=next href=https://brunoluiz.net/blog/2021/jun/redirect-users-client-side-only/><span class=title>Next ¬ª</span><br><span>The forgotten art of HTML redirects, without either HTTP 301 or JavaScript</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://brunoluiz.net/>Bruno Luiz Silva</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>